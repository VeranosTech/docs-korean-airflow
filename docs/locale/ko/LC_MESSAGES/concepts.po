# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Airflow package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Airflow 1.10.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-03 15:37+0900\n"
"PO-Revision-Date: 2019-04-10 10:53+0900\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko\n"
"X-Generator: Poedit 2.2.1\n"

#: ../../concepts.rst:19
msgid "Concepts"
msgstr "개념"

#: ../../concepts.rst:21
msgid ""
"The Airflow platform is a tool for describing, executing, and monitoring "
"workflows."
msgstr ""
"에어플로우 플랫폼은 워크플로우를 설명하고, 실행하고, 모니터링할 수 있는 도구이"
"다."

#: ../../concepts.rst:25
msgid "Core Ideas"
msgstr "핵심 개념"

#: ../../concepts.rst:28
msgid "DAGs"
msgstr "방향성 비순환 그래프"

#: ../../concepts.rst:30
msgid ""
"In Airflow, a ``DAG`` -- or a Directed Acyclic Graph -- is a collection of all "
"the tasks you want to run, organized in a way that reflects their "
"relationships and dependencies."
msgstr ""
"에어플로우 에서, ``DAG`` -- 또는 방향성 비순환 그래프 —는 실행시키고 싶은 모든 "
"태스크의 모음이며, 서로 간의 관계와 의존성을 반영하여 구조화한 것이다."

#: ../../concepts.rst:34
msgid ""
"For example, a simple DAG could consist of three tasks: A, B, and C. It could "
"say that A has to run successfully before B can run, but C can run anytime. It "
"could say that task A times out after 5 minutes, and B can be restarted up to "
"5 times in case it fails. It might also say that the workflow will run every "
"night at 10pm, but shouldn't start until a certain date."
msgstr ""
"예를 들어, 간단한 DAG는 3가지의 태스크: A, B 그리고 C로 구성될 수 있다. A는 B"
"가 실행하기 전에 성공적으로 작업을 마쳐야 하지만, C는 아무때나 실행할 수 있다. "
"5분 후 태스크 A의 시간이 끝나고, B는 실패할 경우에 최대 5회까지 다시 시작될 수 "
"있다. 또한 워크플로우가 매일 밤 10시에 실행될 예정이지만, 특정 날짜 전에는 시작"
"하지 않도록 할 수 있다."

#: ../../concepts.rst:40
msgid ""
"In this way, a DAG describes *how* you want to carry out your workflow; but "
"notice that we haven't said anything about *what* we actually want to do! A, "
"B, and C could be anything. Maybe A prepares data for B to analyze while C "
"sends an email. Or perhaps A monitors your location so B can open your garage "
"door while C turns on your house lights. The important thing is that the DAG "
"isn't concerned with what its constituent tasks do; its job is to make sure "
"that whatever they do happens at the right time, or in the right order, or "
"with the right handling of any unexpected issues."
msgstr ""
"이런 식으로, DAG는 *어떻게* 워크플로우를 실행하길 원하는지 설명한ㄷ; 하지만 *무"
"엇을* 실제로 하고 싶은지에 대해서는 아무것도 말하지 않았다는 것을 주목해라! A, "
"B 그리고 C는 무엇이든 할 수 있다. 아마 A는 B가 분석할 데이터를 준비하는 반면 C"
"가 메일을 보낼 것이다. 또는 A가 당신의 위치를 모니터링해서 B가 차고 문을 열 수 "
"있도록 하는 동안 C는 당신의 집의 불을 켜고 있을 수 있다. 중요한 점은 DAG는 태스"
"크가 할 일이 어떻게 구성되어 있는지 관심 없다는 것이다. DAG의 일은 동시에 어떤 "
"일이 벌어지든 간에, 적시에, 올바른 순서로, 또는 예기치 못한 이슈를 맞게 처리하"
"도록 하는 것이다."

#: ../../concepts.rst:49
msgid ""
"DAGs are defined in standard Python files that are placed in Airflow's "
"``DAG_FOLDER``. Airflow will execute the code in each file to dynamically "
"build the ``DAG`` objects. You can have as many DAGs as you want, each "
"describing an arbitrary number of tasks. In general, each one should "
"correspond to a single logical workflow."
msgstr ""
"DAG는 기본 파이썬 파일안에서 정의되고, 이 파일은 에어플로우의 ``DAG_FOLDER`` 안"
"에 위치한다. 에어플로우는 ``DAG`` 객체를 동적으로 빌드하기 위한 각각의 파일 안"
"의 코드를 실행한다. 원하는 만큼의 많은 DAG를 가질 수 있고, 각각은 임의의 개수만"
"큼의 태스크를 설명하게 된다. 일반적으로, 각 DAG 하나는 단일 논리 워크플로우에 "
"대응해야 한다."

#: ../../concepts.rst:55
msgid ""
"When searching for DAGs, Airflow only considers python files that contain the "
"strings \"airflow\" and \"DAG\" by default. To consider all python files "
"instead, disable the ``DAG_DISCOVERY_SAFE_MODE`` configuration flag."
msgstr ""
"DAG를 찾을 때, 에어플로우는 기본값으로 “airflow” 그리고 “DAG” 문자열을 포함하"
"는 파이썬 파일만을 고려한다.모든 파이썬 파일을 고려하고 싶다면, "
"``DAG_DISCOVERY_SAFE_MODE`` 설정 플래그를 비활성화하라."

#: ../../concepts.rst:61
msgid "Scope"
msgstr "범위"

#: ../../concepts.rst:63
msgid ""
"Airflow will load any ``DAG`` object it can import from a DAGfile. Critically, "
"that means the DAG must appear in ``globals()``. Consider the following two "
"DAGs. Only ``dag_1`` will be loaded; the other one only appears in a local "
"scope."
msgstr ""
"에어플로우는 DAG파일에서 임포트할 수 있는 모든 ``DAG`` 객체를 로드할 것이다. 정"
"확히 말하면, DAG는 ``globals()``\\안 에 있어야만 한다. 다음의 두 개의 DAG를 보"
"자. 오직 ``dag_1``\\만이 로드될 것이다; 다른 DAG는 로컬 범위 안에서만 나타난다."

#: ../../concepts.rst:77
msgid ""
"Sometimes this can be put to good use. For example, a common pattern with "
"``SubDagOperator`` is to define the subdag inside a function so that Airflow "
"doesn't try to load it as a standalone DAG."
msgstr ""
"때때로 이것은 좋은 방법이 될 수 있다. 예를 들어, ``SubDagOperator``\\를 사용한 "
"일반적인 패턴은 함수 내부에 서브dag를 정의하는데 에어플로우가 독립 실행 DAG로 "
"로드하려는 시도를 하지 않게 된다."

#: ../../concepts.rst:82
msgid "Default Arguments"
msgstr "기본 인수값"

#: ../../concepts.rst:84
msgid ""
"If a dictionary of ``default_args`` is passed to a DAG, it will apply them to "
"any of its operators. This makes it easy to apply a common parameter to many "
"operators without having to type it many times."
msgstr ""
"만약 ``default_args``\\의 딕셔너리가 DAG로 전달된다면, DAG의 모든 오퍼레이터에 "
"그 값들이 적용할 것이다. 이것은 많은 오퍼레이터에 여러 번 입력하지 않고도 공통 "
"인수를 적용하기 쉽게 만든다."

#: ../../concepts.rst:99
msgid "Context Manager"
msgstr "컨텍스트 관리자"

#: ../../concepts.rst:101 ../../concepts.rst:159 ../../concepts.rst:186
msgid "*Added in Airflow 1.8*"
msgstr "*에어플로우 1.8에서 추가*"

#: ../../concepts.rst:103
msgid ""
"DAGs can be used as context managers to automatically assign new operators to "
"that DAG."
msgstr ""
"DAG는 새로운 오퍼레이터를 DAG에 자동적으로 할당하는 컨텍스트 관리자로도 사용이 "
"가능하다."

#: ../../concepts.rst:115
msgid "Operators"
msgstr "오퍼레이터"

#: ../../concepts.rst:117
msgid ""
"While DAGs describe *how* to run a workflow, ``Operators`` determine what "
"actually gets done."
msgstr ""
"DAG가 *어떻게* 워크플로우를 실행하는지 설명하는 반면, ``Operators``\\는 실제로 "
"어떤 작업을 수행할지 결정한다."

#: ../../concepts.rst:120
msgid ""
"An operator describes a single task in a workflow. Operators are usually (but "
"not always) atomic, meaning they can stand on their own and don't need to "
"share resources with any other operators. The DAG will make sure that "
"operators run in the correct certain order; other than those dependencies, "
"operators generally run independently. In fact, they may run on two completely "
"different machines."
msgstr ""
"오퍼레이터는 워크플로우의 단일 태스크를 설명한다. 오퍼레이터는 (항상 그런 것은 "
"아니지만) 대개 atomic 단일적인데, 이는 독립적으로 실행할 수 있고 다른 오퍼레이"
"터와 리소스를 공유할 필요가 없다는 의미이다. DAG는 오퍼레이터가 정확하고 특정"
"한 순서에 따라 실행될 수 있도록 보장할 것이다; 그러한 의존성 외에 오퍼레이터는 "
"보통 독립적으로 운영된다. 사실상, 오퍼레이터는 완전히 다른 두 개의 머신에서 작"
"동할 수도 있다."

#: ../../concepts.rst:126
msgid ""
"This is a subtle but very important point: in general, if two operators need "
"to share information, like a filename or small amount of data, you should "
"consider combining them into a single operator. If it absolutely can't be "
"avoided, Airflow does have a feature for operator cross-communication called "
"XCom that is described elsewhere in this document."
msgstr ""
"이것은 미묘하지만 굉장히 중요한 점이다: 보통, 두 개의 오퍼레이터가 파일 이름이"
"나 작은 양의 데이터 등의 정보를 공유한다고 했을 때, 이것들을 하나의 오퍼레이터"
"로 결합하는 것을 고민해볼 수 있다. 이런 상황을 절대적으로 피할 수 없을 경우에"
"는, 에어플로우가 가진 XCom이라는 이름의 오퍼레이터의 상호 통신 기능이 있는데, "
"이 문서의 다른 부분에서 설명한다."

#: ../../concepts.rst:132
msgid "Airflow provides operators for many common tasks, including:"
msgstr ""
"에어플로우는 많은 공통적 태스크를 위한 오퍼레이터를 제공하는데, 다음을 포함한"
"다:"

#: ../../concepts.rst:134
msgid ""
":class:`~airflow.operators.bash_operator.BashOperator` - executes a bash "
"command"
msgstr ""
":class:`~airflow.operators.bash_operator.BashOperator` - bash 명령어를 실행"

#: ../../concepts.rst:135
msgid ""
":class:`~airflow.operators.python_operator.PythonOperator` - calls an "
"arbitrary Python function"
msgstr ""
":class:`~airflow.operators.python_operator.PythonOperator` - 임의의 파이썬 함수"
"를 호출"

#: ../../concepts.rst:136
msgid ":class:`~airflow.operators.email_operator.EmailOperator` - sends an email"
msgstr ":class:`~airflow.operators.email_operator.EmailOperator` - 이메일 전송"

#: ../../concepts.rst:137
msgid ""
":class:`~airflow.operators.http_operator.SimpleHttpOperator` - sends an HTTP "
"request"
msgstr ""
":class:`~airflow.operators.http_operator.SimpleHttpOperator` - HTTP request를 "
"전송"

#: ../../concepts.rst:138
msgid ""
":class:`~airflow.operators.mysql_operator.MySqlOperator`, :class:`~airflow."
"operators.sqlite_operator.SqliteOperator`, :class:`~airflow.operators."
"postgres_operator.PostgresOperator`, :class:`~airflow.operators.mssql_operator."
"MsSqlOperator`, :class:`~airflow.operators.oracle_operator.OracleOperator`, :"
"class:`~airflow.operators.jdbc_operator.JdbcOperator`, etc. - executes a SQL "
"command"
msgstr ""
":class:`~airflow.operators.mysql_operator.MySqlOperator`, :class:`~airflow."
"operators.sqlite_operator.SqliteOperator`, :class:`~airflow.operators."
"postgres_operator.PostgresOperator`, :class:`~airflow.operators.mssql_operator."
"MsSqlOperator`, :class:`~airflow.operators.oracle_operator.OracleOperator`, :"
"class:`~airflow.operators.jdbc_operator.JdbcOperator`, etc. - SQL 명령어 실행"

#: ../../concepts.rst:144
msgid "``Sensor`` - waits for a certain time, file, database row, S3 key, etc..."
msgstr "``Sensor`` - 특정 시간, 파일, 데이터베이스 행, S3키 기타 등등…"

#: ../../concepts.rst:146
msgid ""
"In addition to these basic building blocks, there are many more specific "
"operators: :class:`~airflow.operators.docker_operator.DockerOperator`, :class:"
"`~airflow.operators.hive_operator.HiveOperator`, :class:`~airflow.operators."
"s3_file_transform_operator.S3FileTransformOperator(`, :class:`~airflow."
"operators.presto_to_mysql.PrestoToMySqlTransfer`, :class:`~airflow.operators."
"slack_operator.SlackAPIOperator`... you get the idea!"
msgstr ""
"이러한 기본적인 구성 요소 외에도, 더 많은 수의 특정 오퍼레이터들이 있다: :"
"class:`~airflow.operators.docker_operator.DockerOperator`, :class:`~airflow."
"operators.hive_operator.HiveOperator`, :class:`~airflow.operators."
"s3_file_transform_operator.S3FileTransformOperator(`, :class:`~airflow."
"operators.presto_to_mysql.PrestoToMySqlTransfer`, :class:`~airflow.operators."
"slack_operator.SlackAPIOperator`… you get the idea!"

#: ../../concepts.rst:152
msgid "Operators are only loaded by Airflow if they are assigned to a DAG."
msgstr "오퍼레이터는 DAG에 할당되었을 경우에만 에어플로우에 의해 로드된다."

#: ../../concepts.rst:154
msgid "See :doc:`howto/operator/index` for how to use Airflow operators."
msgstr ""
"에어플로우 오퍼레이터를 어떻게 사용하는지는 :doc:`howto/operator/index`\\를 보"
"라."

#: ../../concepts.rst:157
msgid "DAG Assignment"
msgstr "DAG 할당"

#: ../../concepts.rst:161
msgid ""
"Operators do not have to be assigned to DAGs immediately (previously ``dag`` "
"was a required argument). However, once an operator is assigned to a DAG, it "
"can not be transferred or unassigned. DAG assignment can be done explicitly "
"when the operator is created, through deferred assignment, or even inferred "
"from other operators."
msgstr ""
"오퍼레이터는 DAG에 즉시 할당할 필요가 없다(이전에는 ``dag``\\가 필수 인자였"
"다). 하지만, 오퍼레이터가 DAG에 할당되면, 오퍼레이터는 이동하거나 할당 해제될 "
"수 없다. DAG 할당은 오퍼레이터가 생성됐을 때, 지연 할당을 통해, 또는 심지어 다"
"른 오퍼레이터로부터 간접적으로 추론되었을 때에 명시적으로 이루어질 수 있다."

#: ../../concepts.rst:184
msgid "Bitshift Composition"
msgstr "비트쉬프트 구성"

#: ../../concepts.rst:188
msgid ""
"Traditionally, operator relationships are set with the ``set_upstream()`` and "
"``set_downstream()`` methods. In Airflow 1.8, this can be done with the Python "
"bitshift operators ``>>`` and ``<<``. The following four statements are all "
"functionally equivalent:"
msgstr ""
"전통적으로, 오퍼레이터 관계는 ``set_upstream()``\\과 ``set_downstream()`` 메소"
"드로 설정된다. 에어플로우 1.8에서는 파이썬 비트쉬프트 연산자인 ``>>``\\과 "
"``<<``\\로 할 수 있었다. 아래 4개의 표현은 모두 기능적으로 동일하다:"

#: ../../concepts.rst:201
msgid ""
"When using the bitshift to compose operators, the relationship is set in the "
"direction that the bitshift operator points. For example, ``op1 >> op2`` means "
"that ``op1`` runs first and ``op2`` runs second. Multiple operators can be "
"composed -- keep in mind the chain is executed left-to-right and the rightmost "
"object is always returned. For example:"
msgstr ""
"비트쉬프트를 사용하여 오퍼레이터를 구성할 때, 관계는 비트쉬프트 오퍼레이터 포인"
"트의 방향에 따라 설정된다. 예를 들어, ``op1 >> op2``\\는 ``op1``\\이 먼저 실행"
"되고 ``op2``\\가 두번째로 실행된다는 것을 의미한다. 여러 오퍼레이터들은 조합될 "
"수 있는데 — 이러한 체인은 왼쪽에서 부터 오른쪽으로 실행되고, 가장 오른쪽의 객체"
"가 항상 리턴된다는 것을 기억하라. 아래는 예시이다:"

#: ../../concepts.rst:211 ../../concepts.rst:225 ../../concepts.rst:253
msgid "is equivalent to:"
msgstr "이것은 다음과 동일하다:"

#: ../../concepts.rst:219
msgid ""
"For convenience, the bitshift operators can also be used with DAGs. For "
"example:"
msgstr ""
"편의성을 위해, 비트쉬프트 오퍼레이터는 DAG에서도 사용이 가능하다. 예를 보자:"

#: ../../concepts.rst:232
msgid "We can put this all together to build a simple pipeline:"
msgstr "간단한 파이프라인을 만들기 위해 이러한 모든 것을 사용할 수 있다:"

#: ../../concepts.rst:247
msgid "Bitshift can also be used with lists. For example:"
msgstr "또한 비트쉬프트는 리스트와 함께 사용될 수도 있다. 예를 들어:"

#: ../../concepts.rst:260
msgid "and equivalent to:"
msgstr "이것은 다음과 동일하다:"

#: ../../concepts.rst:267
msgid "Tasks"
msgstr "태스크"

#: ../../concepts.rst:269
msgid ""
"Once an operator is instantiated, it is referred to as a \"task\". The "
"instantiation defines specific values when calling the abstract operator, and "
"the parameterized task becomes a node in a DAG."
msgstr ""
"오퍼레이터가 인스턴스화 되었을 때, 이를 “task”라고 부른다. 인스턴스화란 추상적 "
"오퍼레이터를 호출할 때, 특정한 값을 정의하고, 매개변수화된 태스크는 DAG 안의 노"
"드가 된다."

#: ../../concepts.rst:274
msgid "Task Instances"
msgstr "태스크 인스턴스"

#: ../../concepts.rst:276
msgid ""
"A task instance represents a specific run of a task and is characterized as "
"the combination of a DAG, a task, and a point in time. Task instances also "
"have an indicative state, which could be \"running\", \"success\", \"failed\", "
"\"skipped\", \"up for retry\", etc."
msgstr ""
"태스크 인스턴스는 태스크의 특정한 실행을 나타내고 DAG, 태스크 그리고 특정 시점"
"의 조합으로 특정지어 진다. 태스크 인스턴스는 또한 “running”, “success”, "
"“failed”, “skipped”, “up for retry”, 등으로 상태를 나타낸다."

#: ../../concepts.rst:282
msgid "Task Lifecycle"
msgstr "태스크 주기"

#: ../../concepts.rst:284
msgid ""
"A task goes through various stages from start to completion. In the Airflow UI "
"(graph and tree views), these stages are displayed by a color representing "
"each stage:"
msgstr ""
"태스크는 시작부터 완료까지 다양한 단계를 지난다. 에어플로우 UI(그래프와 트리 "
"뷰)에서는, 각각의 상태가 색깔로 표시되어 보여진다:"

#: ../../concepts.rst:290
msgid "The happy flow consists of the following stages:"
msgstr "행복한 상태의 흐름은 다음의 단계들로 구성된다:"

#: ../../concepts.rst:292
msgid "no status (scheduler created empty task instance)"
msgstr "상태 없음(스케쥴러에서 빈 태스크 인스턴스 생성)"

#: ../../concepts.rst:293
msgid "queued (scheduler placed a task to run on the queue)"
msgstr "대기 상태(스케쥴러가 실행할 태스크를 대기열에 배치)"

#: ../../concepts.rst:294
msgid "running (worker picked up a task and is now running it)"
msgstr "실행 상태(워커가 태스크를 선택하고 실행중)"

#: ../../concepts.rst:295
msgid "success (task completed)"
msgstr "성공 상태(태스크 완료)"

#: ../../concepts.rst:297
msgid ""
"There is also visual difference between scheduled and manually triggered DAGs/"
"tasks:"
msgstr ""
"또한 예약된 DAG/태스크와 수동으로 트리거된 DAG/태스크 사이에는 시각적인 차이가 "
"있다:"

#: ../../concepts.rst:302
msgid ""
"The DAGs/tasks with a black border are scheduled runs, whereas the non-"
"bordered DAGs/tasks are manually triggered, i.e. by `airflow trigger_dag`."
msgstr ""
"검정 선으로 된 DAG/태스크는 예약되어 실행한 것인 반면, 선이 없는 DAG/태스크는 "
"수동으로 트리거된 것, 즉 `airflow trigger_dag`\\이다."

#: ../../concepts.rst:306
msgid "Workflows"
msgstr "워크플로우"

#: ../../concepts.rst:308
msgid ""
"You're now familiar with the core building blocks of Airflow. Some of the "
"concepts may sound very similar, but the vocabulary can be conceptualized like "
"this:"
msgstr ""
"이제 에어플로우의 기본 요소들에 익숙해졌다. 몇가지의 개념은 매우 비슷해 보이지"
"만, 개념적인 용어는 다음과 같다:"

#: ../../concepts.rst:312
msgid "DAG: a description of the order in which work should take place"
msgstr "DAG: 작업이 수행되어야 하는 순서에 대한 설명"

#: ../../concepts.rst:313
msgid "Operator: a class that acts as a template for carrying out some work"
msgstr "오퍼레이터: 어떤 작업을 수행하기 위한 템플릿으로서 역할을 하는 클래스"

#: ../../concepts.rst:314
msgid "Task: a parameterized instance of an operator"
msgstr "태스크: 오퍼레이터의 매개변수화된 인스턴스"

#: ../../concepts.rst:315
msgid ""
"Task Instance: a task that 1) has been assigned to a DAG and 2) has a state "
"associated with a specific run of the DAG"
msgstr ""
"태스크 인스턴스: 1) DAG로 할당된 태스크이고 2) DAG의 특정 수행와 연관된 상태를 "
"가진 태스크"

#: ../../concepts.rst:318
msgid ""
"By combining ``DAGs`` and ``Operators`` to create ``TaskInstances``, you can "
"build complex workflows."
msgstr ""
"``DAGs``\\와 ``Operators``\\를 결합하여 ``TaskInstances``\\를 생성하면 복잡한 "
"워크플로우를 만들 수 있다."

#: ../../concepts.rst:322
msgid "Additional Functionality"
msgstr "추가적인 기능"

#: ../../concepts.rst:324
msgid ""
"In addition to the core Airflow objects, there are a number of more complex "
"features that enable behaviors like limiting simultaneous access to resources, "
"cross-communication, conditional execution, and more."
msgstr ""
"에어플로우 객체외에도, 리소스에 동시 접근 제한, 상호 통신, 조건부 실행 등의 작"
"동을 할 수 있는 많은 수의 복잡한 기능이 있다."

#: ../../concepts.rst:329
msgid "Hooks"
msgstr "훅"

#: ../../concepts.rst:331
msgid ""
"Hooks are interfaces to external platforms and databases like Hive, S3, MySQL, "
"Postgres, HDFS, and Pig. Hooks implement a common interface when possible, and "
"act as a building block for operators. They also use the ``airflow.models."
"connection.Connection`` model to retrieve hostnames and authentication "
"information. Hooks keep authentication code and information out of pipelines, "
"centralized in the metadata database."
msgstr ""
"훅은 외부 플랫폼과 Hive, S3, MySQL, Postgres, HDFS 그리고 Pig와 같은 데이터베이"
"스 사이의 인터페이스이다. 훅은 가능하면 공통된 인터페이스를 구현하고, 오퍼레이"
"터를 위한 기본 요소로서 동작한다. 또한 ``airflow.models.connection."
"Connection`` 모델을 이용하여 호스트이름과 인증 정보를 검색한다. 훅은 인증 코드"
"와 정보를 메타데이터 데이터베이스 안에 중앙 집중화된 파이프라인으로 보관한다."

#: ../../concepts.rst:338
msgid ""
"Hooks are also very useful on their own to use in Python scripts, Airflow "
"airflow.operators.PythonOperator, and in interactive environments like iPython "
"or Jupyter Notebook."
msgstr ""
"또한 훅은 Airflow airflow.operators.PythonOperator와 같은 파이썬 스크립트와 "
"iPython이나 Jupyter Notebook과 같은 인터랙티브 환경에서 사용하기에 매우 유용하"
"다."

#: ../../concepts.rst:343
msgid "Pools"
msgstr "풀"

#: ../../concepts.rst:345
msgid ""
"Some systems can get overwhelmed when too many processes hit them at the same "
"time. Airflow pools can be used to **limit the execution parallelism** on "
"arbitrary sets of tasks. The list of pools is managed in the UI (``Menu -> "
"Admin -> Pools``) by giving the pools a name and assigning it a number of "
"worker slots. Tasks can then be associated with one of the existing pools by "
"using the ``pool`` parameter when creating tasks (i.e., instantiating "
"operators)."
msgstr ""
"일부 시스템들은 너무나 많은 프로세스가 동시에 작동될 때 이것에 압도될 수 있다. "
"에어플로우 풀은 임의의 태스크 집합에서 **병렬적 실행 제한**\\을 사용할 수 있다. "
"풀의 목록은 풀의 이름을 정하고 여러 워커 슬럿에 할당하여 UI(``Menu -> Admin -> "
"Pools``\\)에서 관리한다. 그 다음 태스크는 태스크(즉, 인스턴스화된 오퍼레이터)"
"가 생성될 때 ``pool`` 매개변수를 사용하여 기존에 있는 풀 중 하나와 연결될 수 있"
"다."

#: ../../concepts.rst:363
msgid ""
"The ``pool`` parameter can be used in conjunction with ``priority_weight`` to "
"define priorities in the queue, and which tasks get executed first as slots "
"open up in the pool. The default ``priority_weight`` is ``1``, and can be "
"bumped to any number. When sorting the queue to evaluate which task should be "
"executed next, we use the ``priority_weight``, summed up with all of the "
"``priority_weight`` values from tasks downstream from this task. You can use "
"this to bump a specific important task and the whole path to that task gets "
"prioritized accordingly."
msgstr ""
"``pool`` 파라미터는 ``priority_weight``\\와 함께 사용되어 대기열 내의 우선순위"
"와 풀에서 슬롯이 열리면 어떤 태스크가 처음으로 실행될지를 결정할 수 있다. "
"``priority_weight``\\의 기본값은 ``1``\\이고, 아무 숫자나 될 수 있다. 어떤 태스"
"크가 다음에 실행되어야 할지 평가하기 위해 대기열을 정렬할 때, "
"``priority_weight``\\을 사용하는데, 이는 이번 태스크의 다운스트림에 있는 태스크"
"의 모든 ``priority_weight`` 값으로 요약된 것이다. 이를 이용하여 특정한 중요 태스"
"크를 처리할 수 있고, 그 태스크에 대한 전체 경로가 우선순위에 맞게 정해진다."

#: ../../concepts.rst:373
msgid ""
"Tasks will be scheduled as usual while the slots fill up. Once capacity is "
"reached, runnable tasks get queued and their state will show as such in the "
"UI. As slots free up, queued tasks start running based on the "
"``priority_weight`` (of the task and its descendants)."
msgstr ""
"슬롯이 채워지는 동안 태스크는 평상시와 같이 스케쥴링 될 것이다. 슬롯이 모두 차"
"면 실행중인 태스크는 대기되고 해당 태스크의 상태가 UI에서 보이게 될 것이다. 슬"
"롯이 비워지면, 대기중이던 태스크가 (태스크와 그 자식 태스크들"
"의) ``priority_weight``\\를 기준으로 다시 실행되기 시작한다."

#: ../../concepts.rst:378
msgid ""
"Note that by default tasks aren't assigned to any pool and their execution "
"parallelism is only limited to the executor's setting."
msgstr ""
"기본적으로 태스크는 어떠한 풀에도 할당되지 않고, 그 태스크들의 병렬적 실행이 실"
"행자의 설정에 따라 제한되는 것을 유의하라."

#: ../../concepts.rst:381
msgid "To combine Pools with SubDAGs see the `SubDAGs`_ section."
msgstr "풀과 SubDAG의 조합은 `SubDAGs`_ 부분을 보라."

#: ../../concepts.rst:386
msgid "Connections"
msgstr "커넥션"

#: ../../concepts.rst:388
msgid ""
"The connection information to external systems is stored in the Airflow "
"metadata database and managed in the UI (``Menu -> Admin -> Connections``). A "
"``conn_id`` is defined there and hostname / login / password / schema "
"information attached to it. Airflow pipelines can simply refer to the "
"centrally managed ``conn_id`` without having to hard code any of this "
"information anywhere."
msgstr ""
"외부 시스템과의 커넥션 정보는 에어플로우 메타데이터 데이터베이스에 저장되고 "
"UI(``Menu -> Admin -> Connections``\\)에서 관리된다. ``conn_id``\\는 거기서 정"
"의되고 여기에 호스트이름 / 로그인 / 암호 / 스키마 정보가 첨부된다. 에어플로우 "
"파이프라인은 이러한 정보를 아무데서나 하드코딩할 필요 없이 중앙 관리되는 "
"``conn_id``\\를 간단히 참조할 수 있다."

#: ../../concepts.rst:395
msgid ""
"Many connections with the same ``conn_id`` can be defined and when that is the "
"case, and when the **hooks** uses the ``get_connection`` method from "
"``BaseHook``, Airflow will choose one connection randomly, allowing for some "
"basic load balancing and fault tolerance when used in conjunction with retries."
msgstr ""
"동일한 ``conn_id``\\을 가진 여러 커넥션들이 정의될 수 있고 그런 경우와, "
"**hooks**이 ``BaseHook``\\의``get_connection`` 메소드를 사용할 때 에어플로우는 "
"무작위적으로 하나의 커넥션만 선택하고, 연결을 재시도할 때 기본적인 로드 밸런싱"
"과 장애 허용 범위를 어느 정도 허용하게 된다."

#: ../../concepts.rst:401
msgid ""
"Airflow also has the ability to reference connections via environment "
"variables from the operating system. Then connection parameters must be saved "
"in URI format."
msgstr ""
"또한 에어플로우는 운영체제의 환경 변수를 통해 커넥션을 참조하는 기능이 있다. "
"이 때 커넥션 파라미터는 URI 포맷으로 저장되어 있어야만 한다."

#: ../../concepts.rst:405
msgid ""
"If connections with the same ``conn_id`` are defined in both Airflow metadata "
"database and environment variables, only the one in environment variables will "
"be referenced by Airflow (for example, given ``conn_id`` ``postgres_master``, "
"Airflow will search for ``AIRFLOW_CONN_POSTGRES_MASTER`` in environment "
"variables first and directly reference it if found, before it starts to search "
"in metadata database)."
msgstr ""
"만약 동일한 ``conn_id``\\를 가진 커넥션들이 에어플로우 메타데이터 데이터베이스"
"와 환경 변수 둘 다로 정의되었다면, 환경 변수에 있는 것만 에어플로우에 의해 참조"
"될 것이다(예를 들어, ``conn_id`` ``postgres_master``\\가 주어졌을 때, 에어플로"
"우는 메타데이터 데이터베이스에서 검색을 시작하기 전에, 먼저 환경 변수 안의 "
"``AIRFLOW_CONN_POSTGRES_MASTER``\\를 찾아보고 이를 직접적으로 참조한다)."

#: ../../concepts.rst:412
msgid ""
"Many hooks have a default ``conn_id``, where operators using that hook do not "
"need to supply an explicit connection ID. For example, the default ``conn_id`` "
"for the :class:`~airflow.hooks.postgres_hook.PostgresHook` is "
"``postgres_default``."
msgstr ""
"대부분의 훅은 기본값인 ``conn_id``\\를 가지는데, 그 훅들을 사용하는 오퍼레이터"
"들은 명시적 커넥션 ID를 제공할 필요가 없다. 예를 들어, :class:`~airflow.hooks."
"postgres_hook.PostgresHook`\\를 위한 기본값인 ``conn_id``\\은 "
"``postgres_default``\\이다."

#: ../../concepts.rst:417
msgid ""
"See :doc:`howto/connection/index` for how to create and manage connections."
msgstr ""
"커넥션을 어떻게 생성하고 관리하는지는 :doc:`howto/connection/index`\\을 보라."

#: ../../concepts.rst:420
msgid "Queues"
msgstr "대기열"

#: ../../concepts.rst:422
msgid ""
"When using the CeleryExecutor, the Celery queues that tasks are sent to can be "
"specified. ``queue`` is an attribute of BaseOperator, so any task can be "
"assigned to any queue. The default queue for the environment is defined in the "
"``airflow.cfg``'s ``celery -> default_queue``. This defines the queue that "
"tasks get assigned to when not specified, as well as which queue Airflow "
"workers listen to when started."
msgstr ""
"CeleryExecutor를 사용할 때, 태스크가 전송되는 셀러리의 대기열을 지정할 수 있"
"다. ``quere``\\은 BaseOperator의 속성이기 때문에, 어떤 태스크도 아무 대기열에 "
"할당될 수 있다. 환경에서 기본 대기열은 ``airflow.cfg``\\의 ``celery -> "
"defalut_queue``\\에 정의되어 있다. 이는 지정되지 않았을 때 태스크가 할당되는 대"
"기열뿐만 아니라, 시작할 때 에어플로우 워커가 주목하는 대기열을 정의한다."

#: ../../concepts.rst:429
msgid ""
"Workers can listen to one or multiple queues of tasks. When a worker is "
"started (using the command ``airflow worker``), a set of comma-delimited queue "
"names can be specified (e.g. ``airflow worker -q spark``). This worker will "
"then only pick up tasks wired to the specified queue(s)."
msgstr ""
"워커들은 하나 또는 여러 개의 태스크 대기열을 들을 수 있다. (``airflow worker`` "
"명령어를 사용하여) 워커가 시작될 때, 쉼표로 구분된 대기열 이름의 집합을 지정할 "
"수 있다(예를 들어 ``airflow worker -q spark``\\). 그럼 이 워커는 지정된 대기열에"
"서 연결된 태스크만 선택할 것이다."

#: ../../concepts.rst:434
msgid ""
"This can be useful if you need specialized workers, either from a resource "
"perspective (for say very lightweight tasks where one worker could take "
"thousands of tasks without a problem), or from an environment perspective (you "
"want a worker running from within the Spark cluster itself because it needs a "
"very specific environment and security rights)."
msgstr ""
"이는 특화된 워커가 필요하거나, 자원 관점에서(하나의 워커가 수천개의 태스크를 문"
"제없이 수행할만큼 매우 가벼운 태스크인 경우), 또는 환경 관점에서(매우 구체적인 "
"환경과 보안 권한의 이유로 워커가 스파크 클러스터 내에서 스스로 실행되기를 원할 "
"때) 유용할 수 있다."

#: ../../concepts.rst:441
msgid "XComs"
msgstr "XComs"

#: ../../concepts.rst:443
msgid ""
"XComs let tasks exchange messages, allowing more nuanced forms of control and "
"shared state. The name is an abbreviation of \"cross-communication\". XComs "
"are principally defined by a key, value, and timestamp, but also track "
"attributes like the task/DAG that created the XCom and when it should become "
"visible. Any object that can be pickled can be used as an XCom value, so users "
"should make sure to use objects of appropriate size."
msgstr ""
"XComs은 태스크 사이의 메세지를 교환하게 하고, 제어와 공유 상태의 미묘한 형\b태"
"를 가능하게 한다. 이름은 “cross-communication”의 약칭이다. XComs은 주로 키, 값 "
"그리고 타임스탬프에 의해 정의되지만, XCom을 만든 태스크/DAG와 같은 속성과 언제 "
"보여지는지에 따라 정의되기도 한다. 피클링 될 수 있는 객체는 XCom 값으로 사용될 "
"수 있고, 따라서 사용자는 적절한 크기의 객체를 사용하는지 확실히 해야 한다."

#: ../../concepts.rst:450
msgid ""
"XComs can be \"pushed\" (sent) or \"pulled\" (received). When a task pushes an "
"XCom, it makes it generally available to other tasks. Tasks can push XComs at "
"any time by calling the ``xcom_push()`` method. In addition, if a task returns "
"a value (either from its Operator's ``execute()`` method, or from a "
"PythonOperator's ``python_callable`` function), then an XCom containing that "
"value is automatically pushed."
msgstr ""
"XComs은 “pushed” (전송) 또는 “pulled” (수신)될 수 있다. 태스크가 XCom을 push히"
"면, 일반적으로 다른 태스크에 사용 가능하게 된다. 태스크는 ``xcom_push`` 메소드"
"를 호출함으로써 아무때나 XComs을 push 할 수 있다. 추가적으로, 태스크가 어떤 값"
"을 반환하면(오퍼레이터의 ``execute()`` 메소드로 부터 반환거나 또는 "
"PythonOperator의 ``python__callable`` 함수로 부터 반환됐을 경우), XCom은 그 값"
"을 포함하여 자동적으로 push된다."

#: ../../concepts.rst:457
msgid ""
"Tasks call ``xcom_pull()`` to retrieve XComs, optionally applying filters "
"based on criteria like ``key``, source ``task_ids``, and source ``dag_id``. By "
"default, ``xcom_pull()`` filters for the keys that are automatically given to "
"XComs when they are pushed by being returned from execute functions (as "
"opposed to XComs that are pushed manually)."
msgstr ""
"태스크는 XComs을 검색하기 위해 ``xcom_pull()``\\을 호출하고, ``key``\\, 소스의 "
"``task_ids``\\, 그리고 소스의 ``dag_id``\\와 같은 기준에 따라 선택적으로 필터"
"를 적용한다. 기본적으로 XComs가 실행 함수에서 반환되는 키를 push할 때 (수동으"
"로 push되는 XComs과는 반대로) XComs에 자동으로 주어지는 키에 대한 "
"``xcom_pull()`` 필터는 다음과 같다."

#: ../../concepts.rst:463
msgid ""
"If ``xcom_pull`` is passed a single string for ``task_ids``, then the most "
"recent XCom value from that task is returned; if a list of ``task_ids`` is "
"passed, then a corresponding list of XCom values is returned."
msgstr ""
"만약 ``xcom_pull``\\이 ``task_ids``\\에 대한 단일 문자열을 전달받으면, 해당 태스"
"크에 대한 가장 최근의 XCom 값이 반환된다; 만약 ``task_ids`` 리스트가 전달되면, "
"XCom 값의 관련 리스트가 반환된다."

#: ../../concepts.rst:477
msgid ""
"It is also possible to pull XCom directly in a template, here's an example of "
"what this may look like:"
msgstr ""
"템플릿에서 XCom을 직접적으로 pull하는 것도 가능하며, 다음과 같은 예를 들 수 있"
"다:"

#: ../../concepts.rst:484
msgid ""
"Note that XComs are similar to `Variables`_, but are specifically designed for "
"inter-task communication rather than global settings."
msgstr ""
"XComs은 `Variables`_\\와 비슷하지만, 글로벌 설정보다 내부-태스크 커뮤니케이션"
"을 위해 특징적으로 설계되어 있는 에 유의하라."

#: ../../concepts.rst:489
msgid "Variables"
msgstr "변수"

#: ../../concepts.rst:491
msgid ""
"Variables are a generic way to store and retrieve arbitrary content or "
"settings as a simple key value store within Airflow. Variables can be listed, "
"created, updated and deleted from the UI (``Admin -> Variables``), code or "
"CLI. In addition, json settings files can be bulk uploaded through the UI. "
"While your pipeline code definition and most of your constants and variables "
"should be defined in code and stored in source control, it can be useful to "
"have some variables or configuration items accessible and modifiable through "
"the UI."
msgstr ""
"변수들은 에어플로우에서 단순한 키 값을 임의의 내용을 저장하고 검색하는 일반적"
"인 방법 또는 에어플로우 내의 간단한 키 값을 저장하는 방법이다. 변수들은 "
"UI(``Admin -> Variable``\\), 코드 또는 CLI에서 목록화, 생성, 업데이트 그리고 삭"
"제될 수 있다. 게다가, json 설정 파일을 UI를 통해 한꺼번에 대량으로 업로드할 수 "
"있다. 파이프라인 코드 정의와 대부분의 상수 및 변수는 코드로써 정의되어 있고, 소"
"스 제어에 저장되어야 함에도 불구하고, UI를 통해 접근 가능하고 수정 가능한 변수 "
"또는 설정 항목을 가지는 것 유용할 수 있다."

#: ../../concepts.rst:508
msgid ""
"The second call assumes ``json`` content and will be deserialized into "
"``bar``. Note that ``Variable`` is a sqlalchemy model and can be used as such. "
"The third call uses the ``default_var`` parameter with the value ``None``, "
"which either returns an existing value or ``None`` if the variable isn't "
"defined. The get function will throw a ``KeyError`` if the variable doesn't "
"exist and no default is provided."
msgstr ""
"두번째 호출은 ``json`` 내용을 가정하고 ``bar``\\로 구분될 것이다. ``Variable``\\"
"은 sqlalchemy 모델이고 이와 같이 사용될 수 있음에 유의하라. 세번째 호출은 "
"``None`` 값인 ``default_var`` 파라미터를 사용하는데, 변수가 정의되어 있지 않았"
"으면 현재 존재하는 값 또는 ``None``\\을 리턴한다. 만일 변수가 존재하지 않고 기"
"본값이 제공되지 않을 경우 get 함수는 ``KeyError``\\를 내보낸다."

#: ../../concepts.rst:515
msgid "You can use a variable from a jinja template with the syntax :"
msgstr "Jinja 템플릿을 사용한 문법으로 변수를 사용할 수 있다:"

#: ../../concepts.rst:521
msgid "or if you need to deserialize a json object from the variable :"
msgstr "또는 변수로부터 json 객체를 구분한다:"

#: ../../concepts.rst:529
msgid "Branching"
msgstr "브랜치"

#: ../../concepts.rst:531
msgid ""
"Sometimes you need a workflow to branch, or only go down a certain path based "
"on an arbitrary condition which is typically related to something that "
"happened in an upstream task. One way to do this is by using the "
"``BranchPythonOperator``."
msgstr ""
"어떤 때에는 분기 하기 위한 워크플로우가 필요하거나, 일반적으로 업스트림 태스크"
"에서 일어난 일과 관련한 임의의 조건에 기반하여 특정 경로를 따라 가야한다."

#: ../../concepts.rst:536
msgid ""
"The ``BranchPythonOperator`` is much like the PythonOperator except that it "
"expects a ``python_callable`` that returns a task_id (or list of task_ids). "
"The task_id returned is followed, and all of the other paths are skipped. The "
"task_id returned by the Python function has to reference a task directly "
"downstream from the BranchPythonOperator task."
msgstr ""
"``BranchPythonOperator``\\는 task_id(또는 task_id의 목록)을 반환하는 "
"``python_callable``\\을 기대한다는 점을 제외하고 PythonOperator와 매우 비슷하"
"다. task_id는 다음과 같이 반환되는데, 모든 다른 경로는 건너뛴다. Python 함수에 "
"의해 반환되는 task_id는 BranchPythonOperator 태스크로부터 직접 다운스트림 작업"
"을 참조해야 한다."

#: ../../concepts.rst:542
msgid ""
"Note that when a path is a downstream task of the returned task (list), it "
"will not be skipped:"
msgstr ""
"경로가 반환된 태스크 (목록)의 다운스트림 태스크일 때, 이 경로는 생략되 않음을 "
"유의하라:"

#: ../../concepts.rst:547
msgid ""
"Paths of the branching task are ``branch_a``, ``join`` and ``branch_b``. Since "
"``join`` is a downstream task of ``branch_a``, it will be excluded from the "
"skipped tasks when ``branch_a`` is returned by the Python callable."
msgstr ""
"분기된 태스크의 경로는 ``branch_a``\\, ``join`` 그리고 ``branch_b``\\이다. "
"``join``\\이 ``branch_a``\\의 다운스트림 태스크이기 때문에, ``branch_a``\\가 "
"Python 호출에 의한 반환된 것일 때 생략되는 태스크에서 제외된다."

#: ../../concepts.rst:551
msgid ""
"The ``BranchPythonOperator`` can also be used with XComs allowing branching "
"context to dynamically decide what branch to follow based on previous tasks. "
"For example:"
msgstr ""
"``BranchPython Operator``\\는 XComs과 함께 사용이 가능한데 이전의 태스크에 기반"
"하여 그 다음의 어떤 분기점을 가질지 동적으로 결정하는 분기 맥락을 허용한다. 예"
"를 들면:"

#: ../../concepts.rst:583
msgid "SubDAGs"
msgstr "서브 DAG"

#: ../../concepts.rst:585
msgid ""
"SubDAGs are perfect for repeating patterns. Defining a function that returns a "
"DAG object is a nice design pattern when using Airflow."
msgstr ""
"서브 DAG는 패턴을 반복하기에 아주 좋다. DAG 객체를 반환하는 함수를 정의하는 것"
"은 에어플로우를 사용할 때 아주 좋은 설계 패턴이다."

#: ../../concepts.rst:588
msgid ""
"Airbnb uses the *stage-check-exchange* pattern when loading data. Data is "
"staged in a temporary table, after which data quality checks are performed "
"against that table. Once the checks all pass the partition is moved into the "
"production table."
msgstr ""
"Airbnb는 데이터를 로딩할 때 *stage-check-exchange* 패턴을 사용한다. 데이터는 임"
"시 테이블에서 준비되고, 이후 해당 테이블에 대해서 데이터 품질 검사를 실시한다. "
"검사가 모두 통과되면 해당 파티션이 프로덕션 테이블로 이동된다."

#: ../../concepts.rst:593
msgid "As another example, consider the following DAG:"
msgstr "또 다른 예시로, 다음의 DAG를 보라:"

#: ../../concepts.rst:597
msgid ""
"We can combine all of the parallel ``task-*`` operators into a single SubDAG, "
"so that the resulting DAG resembles the following:"
msgstr ""
"모든 병렬적 ``task-*`` 오퍼레이터를 단일 서브 DAG 내부로 결합하여 결과 DAG가 다"
"음과 유사하도록 할 수 있다:"

#: ../../concepts.rst:602
msgid ""
"Note that SubDAG operators should contain a factory method that returns a DAG "
"object. This will prevent the SubDAG from being treated like a separate DAG in "
"the main UI. For example:"
msgstr ""
"서브 DAG 오퍼레이터는 DAG 객체를 반환하는 팩토리 메서드를 포함해야 함을 유의하"
"라. 이는 서브DAG를 메인 UI에서 구분되어 있는 DAG처럼 다루는 것을 방지한다. 예"
"를 들어 보자:"

#: ../../concepts.rst:628
msgid "This SubDAG can then be referenced in your main DAG file:"
msgstr "이 서브 DAG는 다음의 메인 DAG 파일에서 참조될 수 있다:"

#: ../../concepts.rst:655
msgid ""
"You can zoom into a SubDagOperator from the graph view of the main DAG to show "
"the tasks contained within the SubDAG:"
msgstr ""
"메인 DAG의 그래프 보기에서 SubDagOperator를 확대하여 SubDAG 내에 포함되어 있는 "
"태스크를 볼 수 있다:"

#: ../../concepts.rst:660
msgid "Some other tips when using SubDAGs:"
msgstr "서브 DAG를 사용할 때의 다른 조언들:"

#: ../../concepts.rst:662
msgid ""
"by convention, a SubDAG's ``dag_id`` should be prefixed by its parent and a "
"dot. As in ``parent.child``"
msgstr ""
"컨벤션에 따라, 서브 DAG의 ``dag_id``\\는 이것의 부모와 점으로 된 접두어를 가져"
"야 한다. ``parent.child``\\처"

#: ../../concepts.rst:664
msgid ""
"share arguments between the main DAG and the SubDAG by passing arguments to "
"the SubDAG operator (as demonstrated above)"
msgstr ""
"인자를 서브 DAG 오퍼레이터로 전달함으로써 메인 DAG와 서브 DAG 사이의 인자를 공"
"유한다(위의 예시처럼)"

#: ../../concepts.rst:666
msgid ""
"SubDAGs must have a schedule and be enabled. If the SubDAG's schedule is set "
"to ``None`` or ``@once``, the SubDAG will succeed without having done anything"
msgstr ""
"서브 DAG는 반드시 스케쥴이 있어야 하고 황성화되어야 한다. 만일 서브 DAG의 스케"
"쥴이 ``None``\\이나 ``@once``\\로 설정되어 있다면, 서브 DAG는 아무것도 하지 않"
"은 상태로 성공 상태 일 것이다"

#: ../../concepts.rst:669
msgid "clearing a SubDagOperator also clears the state of the tasks within"
msgstr "이 SubDagOperator를 지우면 내부 태스크 상태도 지워진다"

#: ../../concepts.rst:670
msgid ""
"marking success on a SubDagOperator does not affect the state of the tasks "
"within"
msgstr ""
"이 SubDagOperator에서 성공 여부를 표시하는 것은 태스크 상태에 영향을 미치지 않"
"는다"

#: ../../concepts.rst:672
msgid ""
"refrain from using ``depends_on_past=True`` in tasks within the SubDAG as this "
"can be confusing"
msgstr ""
"서브 DAG 안에서 태스크의 ``depends_on_past=True``\\를 사용하는 것이 혼란스러울 "
"수 있다면 이를 자제하라"

#: ../../concepts.rst:674
msgid ""
"it is possible to specify an executor for the SubDAG. It is common to use the "
"SequentialExecutor if you want to run the SubDAG in-process and effectively "
"limit its parallelism to one. Using LocalExecutor can be problematic as it may "
"over-subscribe your worker, running multiple tasks in a single slot"
msgstr ""
"서브 DAG의 실행자를 명시하는 것은 가능하다. 서브 DAG를 진행중인 상태로 실행하"
"고 병렬 처리를 효과적으로 제한하려는 경우 SequentialExecutor를 사용하는 것이 일"
"반적이다. LocalExecutor를 사용하면 하나의 슬롯에 여러 태스크를 실행하면서 워커"
"에 초과할당하게 됨으로 문제가 발생할 수 있다"

#: ../../concepts.rst:680
msgid "See ``airflow/example_dags`` for a demonstration."
msgstr "데모 ``airflow/example_dags``\\를 보라."

#: ../../concepts.rst:682
msgid ""
"Note that airflow pool is not honored by SubDagOperator. Hence resources could "
"be consumed by SubdagOperators."
msgstr ""
"에어플로우 풀은 SubDagOperator에서 통용되지 않음을 유의하라. 따라서 리소스는 "
"SubdagOperator에 의해 소비될 수 있다."

#: ../../concepts.rst:686
msgid "SLAs"
msgstr "SLAs"

#: ../../concepts.rst:688
msgid ""
"Service Level Agreements, or time by which a task or DAG should have "
"succeeded, can be set at a task level as a ``timedelta``. If one or many "
"instances have not succeeded by that time, an alert email is sent detailing "
"the list of tasks that missed their SLA. The event is also recorded in the "
"database and made available in the web UI under ``Browse->SLA Misses`` where "
"events can be analyzed and documented."
msgstr ""
"서비스 수준의 동의 또는 태스크나 DAG가 수행되는 시간은 태스크의 수준을 "
"``timedelta`` 정도로 설정할 수 있다. 그때까지 한 개 또는 여러 개의 인스턴스가 "
"성공하지 못한다면, SLA가 놓친 태스크의 목록을 자세 설명하는 알림 이메일이 전송"
"된다. 또한 이 이벤트는 데이터베이스에도 저장되고 이벤트가 분석되고 문서화되는 "
"``Browse->SLA Misses` 아래의 웹 UI에서도 제공된다."

#: ../../concepts.rst:696
msgid "Email Configuration"
msgstr "이메일 설정"

#: ../../concepts.rst:698
msgid ""
"You can configure the email that is being sent in your ``airflow.cfg`` by "
"setting a ``subject_template`` and/or a ``html_content_template`` in the "
"``email`` section."
msgstr ""
"``email`` 섹션에 ``html_content_template``\\이나 ``subject_template``\\을 설정함"
"으로써 ``airflow.cfg``\\로 전송되는 이메일을 설정할 수 있다."

#: ../../concepts.rst:711
msgid ""
"To access the task's information you use `Jinja Templating <http://jinja.pocoo."
"org/docs/dev/>`_  in your template files."
msgstr ""
"태스크의 정보에 접근할 수 있도록  템플릿 파인 안에서 `Jinja Templating <http://"
"jinja.pocoo.org/docs/dev/>`_  \\을 사용한다."

#: ../../concepts.rst:713
msgid "For example a ``html_content_template`` file could look like this:"
msgstr "예를 들어 ``html_content_template`` 파일은 다음과 같이 생겼다:"

#: ../../concepts.rst:725
msgid "Trigger Rules"
msgstr "트리거 규칙"

#: ../../concepts.rst:727
msgid ""
"Though the normal workflow behavior is to trigger tasks when all their "
"directly upstream tasks have succeeded, Airflow allows for more complex "
"dependency settings."
msgstr ""
"일반적인 워크플로우를 통한 행동은 모든 직접 업스트림 작업이 성공했을 때 작업을 "
"트리거하는 것이지만, 에어플로는 더 복잡한 종속성 설정을 허용한다."

#: ../../concepts.rst:731
msgid ""
"All operators have a ``trigger_rule`` argument which defines the rule by which "
"the generated task get triggered. The default value for ``trigger_rule`` is "
"``all_success`` and can be defined as \"trigger this task when all directly "
"upstream tasks have succeeded\". All other rules described here are based on "
"direct parent tasks and are values that can be passed to any operator while "
"creating tasks:"
msgstr ""
"모든 오퍼레이터는 생성된 태스크가 트리거 하는 방식을 정의하는 ``trigger_rule`` "
"인자를 가지고 있다. ``trigger_rule``\\의 기본값은 ``all_success``\\이고, 이것"
"은 “모든 직접적인 업스트림 태스크가 성공했을 때 이 태스크를 트리거하는” 것으로 "
"정의될 수 있다. 여기에 설명된 모든 다른 규칙들은 직계 부모 태스크에 기반하며 태"
"스크가 생성되는 동안 다른 오퍼레이터로 전달될 수 있는 값이다:"

#: ../../concepts.rst:738
msgid "``all_success``: (default) all parents have succeeded"
msgstr "``all_success``\\: (기본값) 모든 부모가 성공"

#: ../../concepts.rst:739
msgid ""
"``all_failed``: all parents are in a ``failed`` or ``upstream_failed`` state"
msgstr ""
"``all_failed``\\: 모든 부모가 ``failed``\\이거나 ``upstream_failed`` 상태"

#: ../../concepts.rst:740
msgid "``all_done``: all parents are done with their execution"
msgstr "``all_done``\\: 모든 부모가 실행을 마침"

#: ../../concepts.rst:741
msgid ""
"``one_failed``: fires as soon as at least one parent has failed, it does not "
"wait for all parents to be done"
msgstr ""
"``one_failed``\\: 최소 하나의 부모가 실패한 순간에 바로 실행, 모든 부모가 완료"
"될 때까지 기다리지 않음"

#: ../../concepts.rst:742
msgid ""
"``one_success``: fires as soon as at least one parent succeeds, it does not "
"wait for all parents to be done"
msgstr ""
"``one_success``\\: 하나의 부모가 성공한 순간에 바로 실행, 모든 부모가 완료될 때"
"까지 기다리지 않음"

#: ../../concepts.rst:743
msgid ""
"``none_failed``: all parents have not failed (``failed`` or "
"``upstream_failed``) i.e. all parents have succeeded or been skipped"
msgstr ""
"``none_failed``\\: 모든 부모가 실패(``failed`` 또는 ``upstream_failed``\\)하지 "
"않음. 예를 들어 모든 부모가 성공하거나 생략한 것"

#: ../../concepts.rst:744
msgid "``dummy``: dependencies are just for show, trigger at will"
msgstr "``dummy``\\: 의존성은 단지 보기만 하고, 트리거 실행"

#: ../../concepts.rst:746
msgid ""
"Note that these can be used in conjunction with ``depends_on_past`` (boolean) "
"that, when set to ``True``, keeps a task from getting triggered if the "
"previous schedule for the task hasn't succeeded."
msgstr ""
"이러한 방법은 ``True``\\로 설정된 경우에, 이전에 스케쥴에서 성공 여부에 따라 태"
"스크가 트리거 되도록 하는 ``depends_on_past``\\(boolean)와 함께 사용함을 유의하"
"라."

#: ../../concepts.rst:750
msgid ""
"One must be aware of the interaction between trigger rules and skipped tasks "
"in schedule level. Skipped tasks will cascade through trigger rules "
"``all_success`` and ``all_failed`` but not ``all_done``, ``one_failed``, "
"``one_success``, ``none_failed`` and ``dummy``."
msgstr ""
"트리거 규칙과 스케쥴 레벨에서 생략된 태스크 사이의 상호작용을 잘 알아야 한다. "
"생략된 태스크는 트리거 규칙 ``all_success``\\와 ``all_failed``\\을 차례로 통과"
"하지만 ``all_done``\\, ``one_failed``\\, ``one_Success``\\, ``none_failed`` 그"
"리고 ``dummy``\\는 통과하지 않는다."

#: ../../concepts.rst:755 ../../concepts.rst:827
msgid "For example, consider the following DAG:"
msgstr "예를 들어, 다음의 DAG를 살펴보자:"

#: ../../concepts.rst:789
msgid ""
"In the case of this DAG, ``join`` is downstream of ``follow_branch_a`` and "
"``branch_false``. The ``join`` task will show up as skipped because its "
"``trigger_rule`` is set to ``all_success`` by default and skipped tasks will "
"cascade through ``all_success``."
msgstr ""
"이러한 경우의 DAG는, ``join``\\은 ``follow_branch_a``\\와 ``branch_false``\\의 "
"다운스트림이다. ``join`` 태스크는 생략된 상태로 보여지는데 그 이유는 이 태스크"
"의 ``trigger_rule``\\이 기본적으로 ``all_success``\\으로 설정되었고 생략된 태스"
"크는 ``all_success``\\를 연결하여 지나갈 것이기 때문이다."

#: ../../concepts.rst:796
msgid "By setting ``trigger_rule`` to ``none_failed`` in ``join`` task,"
msgstr "``join`` 태스크 안의 ``trigger_rule``\\을 ``none_failed``\\로 설정하면,"

#: ../../concepts.rst:805
msgid ""
"The ``join`` task will be triggered as soon as ``branch_false`` has been "
"skipped (a valid completion state) and ``follow_branch_a`` has succeeded. "
"Because skipped tasks **will not** cascade through ``none_failed``."
msgstr ""
"``join`` 태스크는 ``branch_false``\\이 생략되고(유효한 완료 상태) "
"``follow_branch_a``\\가 성공한 순간에 바로 트리거 될 것이다. 그 이유는 생략된 "
"태스크가 ``none_failed``\\를 연결하여 통하지 **않을 것이기** 때문이다."

#: ../../concepts.rst:813
msgid "Latest Run Only"
msgstr "최근 실행된 태스크"

#: ../../concepts.rst:815
msgid ""
"Standard workflow behavior involves running a series of tasks for a particular "
"date/time range. Some workflows, however, perform tasks that are independent "
"of run time but need to be run on a schedule, much like a standard cron job. "
"In these cases, backfills or running jobs missed during a pause just wastes "
"CPU cycles."
msgstr ""
"표준 워크플로우 행동은 특정 날짜/시간 범위 동안에 일련의 태스크를 실행하는 것"
"을 포함한다. 하지만, 일부 워크플로우는 실행 시간과는 별개로 태스크를 수행하지"
"만 표준 크론 작업처럼 스케쥴에 따라 실행하는 태스크를 수행하기도 한다. 이러한 "
"경우, 일시 중지 중에 누락된 백필(backfill)이나 실행 작업은 CPU 사이클을 낭비하"
"기만 한다."

#: ../../concepts.rst:821
msgid ""
"For situations like this, you can use the ``LatestOnlyOperator`` to skip tasks "
"that are not being run during the most recent scheduled run for a DAG. The "
"``LatestOnlyOperator`` skips all downstream tasks, if the time right now is "
"not between its ``execution_time`` and the next scheduled ``execution_time``."
msgstr ""
"이러한 경우를 위해, DAG를 위한 최근 스케쥴 동안에 실행되지 않은 태스크를 생략하"
"기 위해 ``LatestOnlyOperator``\\를 사용할 수 있다. ``LatestOnlyOperator``\\는 "
"만일 지금 당장이 현재 ``execution_time``\\과 다음 예정된 ``execution_time`` 사이"
"가 아닌 경우일 때 모든 다운스트림 태스크를 생략한다."

#: ../../concepts.rst:860
msgid ""
"In the case of this DAG, the ``latest_only`` task will show up as skipped for "
"all runs except the latest run. ``task1`` is directly downstream of "
"``latest_only`` and will also skip for all runs except the latest. ``task2`` "
"is entirely independent of ``latest_only`` and will run in all scheduled "
"periods. ``task3`` is downstream of ``task1`` and ``task2`` and because of the "
"default ``trigger_rule`` being ``all_success`` will receive a cascaded skip "
"from ``task1``. ``task4`` is downstream of ``task1`` and ``task2``. It will be "
"first skipped directly by ``LatestOnlyOperator``, even its ``trigger_rule`` is "
"set to ``all_done``."
msgstr ""
"이 DAG의 경우, ``latest_only`` 태스크는 가장 최근의 실행을 제외한 모든 실행을 "
"생략하여 보여줄 것이다. ``task1``\\은 ``latest_only``\\의 직접적인 다운스크림이"
"고 최근 것을 제외한 모든 실행을 생략할 것이다. ``task2``\\는 ``latest_only``"
"\\에 전적으로 독립되어 있으며 모든 예정된 기간 동안에 실행할 것이다. ``task3``"
"\\은 ``task1``\\와 ``tast2``\\의 다운스트림이며 기본 ``trigger_rule``\\이 "
"``all_success``\\이기 때문에 ``task1``\\에서부터 일괄적으로 생략될 것이다. "
"``task4``\\는 ``task1``\\과 ``task2``\\의 다운스트림이다. 이것은 처음에 "
"``LatestOnlyOperator``\\에 의해 직접 생략될 것이며, ``trigger_rule``\\은 "
"``all_done``\\으로 설정되어 있다."

#: ../../concepts.rst:874
msgid "Zombies & Undeads"
msgstr "좀비와 완전히 죽지 않은 태스크"

#: ../../concepts.rst:876
msgid ""
"Task instances die all the time, usually as part of their normal life cycle, "
"but sometimes unexpectedly."
msgstr ""
"태스크 인스턴스는 항상 사라지며, 보통 일반적인 라이프 사이클의 한 부분이지만, "
"어떨 때는 예상하지 못한 순간에 죽기도 하다."

#: ../../concepts.rst:879
msgid ""
"Zombie tasks are characterized by the absence of an heartbeat (emitted by the "
"job periodically) and a ``running`` status in the database. They can occur "
"when a worker node can't reach the database, when Airflow processes are killed "
"externally, or when a node gets rebooted for instance. Zombie killing is "
"performed periodically by the scheduler's process."
msgstr ""
"좀비 태스크는 심장박동(주기적인 실행에서 나오는)가 없으며 데이터베이스에서는 "
"``running`` 상태인 것이 특징이다. 워커 노드가 데이터베이스에 도달하지 못할 때, "
"에어플로우 프로세스가 외부에서 킬 되었을 때, 또는 노드가 인스턴스로 다시 부팅되"
"었을 때 발생할 수 있다. 좀비 태스크를 제거하는 것은 스케쥴러의 프로세스에 의해 "
"주기적으로 수행된다."

#: ../../concepts.rst:886
msgid ""
"Undead processes are characterized by the existence of a process and a "
"matching heartbeat, but Airflow isn't aware of this task as ``running`` in the "
"database. This mismatch typically occurs as the state of the database is "
"altered, most likely by deleting rows in the \"Task Instances\" view in the "
"UI. Tasks are instructed to verify their state as part of the heartbeat "
"routine, and terminate themselves upon figuring out that they are in this "
"\"undead\" state."
msgstr ""
"죽지 않은 프로세스들은 프로세스와 이에 일치하는 심장 박동이 있는 것이 특징이지"
"만, 에어플로우는 이 태스크가 데이터베이스에서 ``running`` 상태인 것으로 알지 못"
"한다. 이러한 불일치는 일반적으로 데이터베이스가 변경되는 상태에서 발생하며, 대"
"부분의 경우 UI의 “Task Instances” 보기에서 행을 삭제하며 발생할 수 있다. 태스"
"크는 심장 박동 루틴의 일부로 상태를 확인하고, “undead” 상태인지를 판별하는 것을 "
"알게 되면 스스로 종료하도록 지시받는다."

#: ../../concepts.rst:896
msgid "Cluster Policy"
msgstr "클러스터 정책"

#: ../../concepts.rst:898
msgid ""
"Your local Airflow settings file can define a ``policy`` function that has the "
"ability to mutate task attributes based on other task or DAG attributes. It "
"receives a single argument as a reference to task objects, and is expected to "
"alter its attributes."
msgstr ""
"로컬 에어플로우 설정 파일은 DAG 속성 또는 다른 태스크에 따라 태스크 속성을 변형"
"하는 기능을 가진 ``policy`` 함수를 정의할 수 있다. 테스크 객체를 참조하는 단일 "
"인자를 받으면, 해당 속성을 변경될 것으로 예상한다."

#: ../../concepts.rst:903
msgid ""
"For example, this function could apply a specific queue property when using a "
"specific operator, or enforce a task timeout policy, making sure that no tasks "
"run for more than 48 hours. Here's an example of what this may look like "
"inside your ``airflow_settings.py``:"
msgstr ""
"예를 들어, 이 함수는 특정 오퍼레이터를 사용할 때 특정 대기열 속성을 적용하거나 "
"태스크 타임아웃 정책을 적용하여 48시간 이상 동안 태스크가 실행되지 않도록 할 "
"수 있다. 여기 ``airflow_settings.py``\\안에 어떻게 생겼는지 보여주는 예시가 있"
"다:"

#: ../../concepts.rst:919
msgid "Documentation & Notes"
msgstr "문서와 노트"

#: ../../concepts.rst:921
msgid ""
"It's possible to add documentation or notes to your DAGs & task objects that "
"become visible in the web interface (\"Graph View\" for DAGs, \"Task Details\" "
"for tasks). There are a set of special task attributes that get rendered as "
"rich content if defined:"
msgstr ""
"웹 인터페이스(DAG를 위한 “Graph View”, 태스크를 위한 “Task Details”)에서 보이"
"는 DAG와 태스크 객체에 문서나 노트를 추가하는 것이 가능하다. 정의 되었을 때 리"
"치 콘텐츠로 렌더링되는 특별한 태스크 속성이 있다:"

#: ../../concepts.rst:927
msgid "attribute"
msgstr "속성"

#: ../../concepts.rst:927
msgid "rendered to"
msgstr "렌더링 되는 것"

#: ../../concepts.rst:929
msgid "doc"
msgstr "doc"

#: ../../concepts.rst:929
msgid "monospace"
msgstr "monospace"

#: ../../concepts.rst:930
msgid "doc_json"
msgstr "doc_json"

#: ../../concepts.rst:930
msgid "json"
msgstr "json"

#: ../../concepts.rst:931
msgid "doc_yaml"
msgstr "doc_yaml"

#: ../../concepts.rst:931
msgid "yaml"
msgstr "yaml"

#: ../../concepts.rst:932
msgid "doc_md"
msgstr "doc_md"

#: ../../concepts.rst:932
msgid "markdown"
msgstr "markdown"

#: ../../concepts.rst:933
msgid "doc_rst"
msgstr "doc_rst"

#: ../../concepts.rst:933
msgid "reStructuredText"
msgstr "reStructuredText"

#: ../../concepts.rst:936
msgid "Please note that for DAGs, doc_md is the only attribute interpreted."
msgstr "DAG의 경우 doc_md만이 속성만이 해석된다는 것을 유의하라."

#: ../../concepts.rst:938
msgid ""
"This is especially useful if your tasks are built dynamically from "
"configuration files, it allows you to expose the configuration that led to the "
"related tasks in Airflow."
msgstr ""
"이는 특히 태스크가 설정 파일로부터 동적으로 빌드됐을 경우에 유용하고, 에어플로"
"우 안에서 관련된 태스크로 이어지는 구성을 노출시킬 수 있도록 허용한다."

#: ../../concepts.rst:957
msgid ""
"This content will get rendered as markdown respectively in the \"Graph View\" "
"and \"Task Details\" pages."
msgstr ""
"이 내용은 “Graph View”와 “Task Details” 페이지에서 각각 마크다운 형태로 렌더링 "
"된다."

#: ../../concepts.rst:963
msgid "Jinja Templating"
msgstr "Jinja 템플릿"

#: ../../concepts.rst:965
msgid ""
"Airflow leverages the power of `Jinja Templating <http://jinja.pocoo.org/docs/"
"dev/>`_ and this can be a powerful tool to use in combination with macros (see "
"the :doc:`macros` section)."
msgstr ""
"에어플로우는 `Jinja Templating <http://jinja.pocoo.org/docs/dev/>`_ \\의 힘을 "
"활용하는데, 이는 매크로와 결합하여 사용하는데 강력한 도구가 될 수 있다(:doc:"
"`macros` 부분을 보라)."

#: ../../concepts.rst:969
msgid ""
"For example, say you want to pass the execution date as an environment "
"variable to a Bash script using the ``BashOperator``."
msgstr ""
"예를 들어, `BashOperator``\\를 사용하여 bash 스크립트에 실행 날짜를 환경 변수로"
"써 넘기고 싶다고 하자."

#: ../../concepts.rst:982
msgid ""
"Here, ``{{ ds }}`` is a macro, and because the ``env`` parameter of the "
"``BashOperator`` is templated with Jinja, the execution date will be available "
"as an environment variable named ``EXECUTION_DATE`` in your Bash script."
msgstr ""
"여기, ``{{ ds }}``\\는 매크로이고, ``BashOperator``\\의 ``env`` 파라미터가 "
"Jinja 템플릿으로 되어 있기 때문에, 실행 날짜는 bash 스크립트에서 "
"``EXECUTION_DATE``\\라는 이름의 환경 변수로 사용이 가능할 것이다."

#: ../../concepts.rst:986
msgid ""
"You can use Jinja templating with every parameter that is marked as \"templated"
"\" in the documentation. Template substitution occurs just before the "
"pre_execute function of your operator is called."
msgstr ""
"문서에서 “templated”로 표시된 모든 파라미터는 Jinja 템플릿화 해서 사용할 수 있"
"다. 템플릿의 대입은 오퍼레이터의 pre_execute 함수가 호출되기 바로 직전에 발생한"
"다."

#: ../../concepts.rst:991
msgid "Packaged DAGs"
msgstr "패키지 된 DAG"

#: ../../concepts.rst:992
msgid ""
"While often you will specify DAGs in a single ``.py`` file it might sometimes "
"be required to combine a DAG and its dependencies. For example, you might want "
"to combine several DAGs together to version them together or you might want to "
"manage them together or you might need an extra module that is not available "
"by default on the system you are running Airflow on. To allow this you can "
"create a zip file that contains the DAG(s) in the root of the zip file and "
"have the extra modules unpacked in directories."
msgstr ""
"단일 ``.py`` 파일에서 DAG를 명시하는 경우가 많지만 때로는 DAG와 그 종속성을 결"
"합하는 것이 요구될 때가 있다. 예를 들어, 여러 개의 한 번에 DAG를 결합하여 함께 "
"버전을 만들거나 함께 관리하거나 에어플로우를 실행하는 시스템에서 기본값으로 사"
"용할 수 없는 추가적인 모듈이 필요할 수 있다. 이러한 것들을 허용하기 위해 파일 "
"루트에 DAG가 들어있는 zip 파일을 생성하고 디렉토리 내에 추가 모듈을 언팩할 수 "
"있다."

#: ../../concepts.rst:1000
msgid "For instance you can create a zip file that looks like this:"
msgstr "예를 들어 다음과 같이 zip 파일을 생성할 수 있다:"

#: ../../concepts.rst:1009
msgid ""
"Airflow will scan the zip file and try to load ``my_dag1.py`` and ``my_dag2."
"py``. It will not go into subdirectories as these are considered to be "
"potential packages."
msgstr ""
"에어플로우는 zip 파일을 살펴보고 ``my_dag1.py``\\와 ``my_dag2.py``\\를 로드하"
"려 시도할 것이다. 이는 잠재적인 패키지가 될 수 있는 것으로 보기 때문에 있는 하"
"위 디렉토리 내에 들어가지 않을 것이다."

#: ../../concepts.rst:1013
msgid ""
"In case you would like to add module dependencies to your DAG you basically "
"would do the same, but then it is more to use a virtualenv and pip."
msgstr ""
"DAG에 모듈 의존성을 추가하고 싶을 경우 기본적으로 동일하게 하면 되지만 "
"virtualenv와 pip을 더 사용하게 된다."

#: ../../concepts.rst:1029
msgid ""
"the zip file will be inserted at the beginning of module search list (sys."
"path) and as such it will be available to any other code that resides within "
"the same interpreter."
msgstr ""
"이 zip 파일은 모듈 검색 목록의 시작 부분에 삽입되며 동일한 인터프리터 내의 다"
"른 코드에서 사용이 가능할 것이다."

#: ../../concepts.rst:1033
msgid "packaged dags cannot be used with pickling turned on."
msgstr "패키지 된 dag들은 피클링되어 사용할 수 없다."

#: ../../concepts.rst:1035
msgid ""
"packaged dags cannot contain dynamic libraries (eg. libz.so) these need to be "
"available on the system if a module needs those. In other words only pure "
"python modules can be packaged."
msgstr ""
"패키지 된 dag는 모듈에서 시스템에서 사용할 수 있는 동적 라이브러리(예를 들어 "
"libz.so)를 필요로 할 경우라도 이러한 동적 라이브러리를 포함"
"할 수 없다."

#: ../../concepts.rst:1041
msgid ".airflowignore"
msgstr ".airflowignore"

#: ../../concepts.rst:1043
msgid ""
"A ``.airflowignore`` file specifies the directories or files in ``DAG_FOLDER`` "
"that Airflow should intentionally ignore. Each line in ``.airflowignore`` "
"specifies a regular expression pattern, and directories or files whose names "
"(not DAG id) match any of the patterns would be ignored (under the hood, ``re."
"findall()`` is used to match the pattern). Overall it works like a ``."
"gitignore`` file."
msgstr ""
"``.airflowignore`` 파일은 ``DAG_FOLDER`` 안의 디렉토리나 파일을 명시하는데 에어"
"플로우는 의도적으로 이것을 무시해야 한다. ``.airflowignore``\의 각 행은 정규 표현"
"식 패턴으로 작성되는데, 이 패턴과 매치되는 이름의 모든 디렉토리 또는 파일(DAG "
"id는 아님)은 무시될 것이다(hood 아래에서는 패턴과 일치하는 ``re.findall()``"
"\\을 사용한다). 대체로 ``.gitignore`` 파일처럼 작동한다."

#: ../../concepts.rst:1050
msgid ""
"``.airflowignore`` file should be put in your ``DAG_FOLDER``. For example, you "
"can prepare a ``.airflowignore`` file with contents"
msgstr ""
"``.airflowignore`` 파일은 ``DAG_FOLDER`` 내부에 있어야 한다. 예를 들어, 아래의 "
"내용을 담고 있는 ``.airflowignore`` 파일을 준비했다고 하자"

#: ../../concepts.rst:1059
msgid ""
"Then files like \"project_a_dag_1.py\", \"TESTING_project_a.py\", \"tenant_1.py"
"\", \"project_a/dag_1.py\", and \"tenant_1/dag_1.py\" in your ``DAG_FOLDER`` "
"would be ignored (If a directory's name matches any of the patterns, this "
"directory and all its subfolders would not be scanned by Airflow at all. This "
"improves efficiency of DAG finding)."
msgstr ""
"“DAG_FOLDER” 내의 “project_a_dag_1.py”, “TESTING_project_a.py”, “tenant_1.py”, "
"“project_a/dag_1.py”, 그리고 “tenant_1/dag_1.py”와 같은 파일들은 무시될 것이다"
"(만약 디렉토리 이름이 이런 패턴과 매치될 경우, 이 디렉토리와 내부의 하위 폴더들"
"은 Airflow에 의해 스캔되지 않을 것이다. 이는 DAG 파인딩의 효율성을 높인다)."

#: ../../concepts.rst:1064
msgid ""
"The scope of a ``.airflowignore`` file is the directory it is in plus all its "
"subfolders. You can also prepare ``.airflowignore`` file for a subfolder in "
"``DAG_FOLDER`` and it would only be applicable for that subfolder."
msgstr ""
"``.airflowignore`` 파일의 범위는 디렉토리와 그 하위의 모든 폴더이다. 또한 ``."
"airflowignore`` 파일을 ``DAG_FOLDER``\\의 하위 폴더 안에 놓을 수 있으며 그 하"
"위 서브폴더 내에서만 적용될 것이다."
