<!--
Javascript to render AIRFLOW-XXX and PR references in text
as HTML links.

Overrides extrahead block from sphinx_rtd_theme
https://www.sphinx-doc.org/en/master/templating.html
-->



<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ko" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ko" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>개념 &mdash; Airflow Documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="색인" href="genindex.html" />
    <link rel="search" title="검색" href="search.html" />
    <link rel="next" title="Command Line Interface" href="cli.html" />
    <link rel="prev" title="UI / 스크린샷(Screenshots)" href="ui.html" />
   
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      var el = document.getElementById('changelog');
      if (el !== null ) {
        // [AIRFLOW-...]
        el.innerHTML = el.innerHTML.replace(
            /\[(AIRFLOW-[\d]+)\]/g,
            `<a href="https://issues.apache.org/jira/browse/$1">[$1]</a>`
        );
        // (#...)
        el.innerHTML = el.innerHTML.replace(
            /\(#([\d]+)\)/g,
            `<a href="https://github.com/apache/airflow/pull/$1">(#$1)</a>`
        );
      };
    })
  </script>
  <style>
    .example-header {
      position: relative;
      background: #9AAA7A;
      padding: 8px 16px;
      margin-bottom: 0;
    }
    .example-header--with-button {
      padding-right: 166px;
    }
    .example-header:after{
      content: '';
      display: table;
      clear: both;
    }
    .example-title {
      display:block;
      padding: 4px;
      margin-right: 16px;
      color: white;
      overflow-x: auto;
    }
    .example-header-button {
      top: 8px;
      right: 16px;
      position: absolute;
    }
    .example-header + .highlight-python {
      margin-top: 0 !important;
    }
    .viewcode-button {
      display: inline-block;
      padding: 8px 16px;
      border: 0;
      margin: 0;
      outline: 0;
      border-radius: 2px;
      -webkit-box-shadow: 0 3px 5px 0 rgba(0,0,0,.3);
      box-shadow: 0 3px 6px 0 rgba(0,0,0,.3);
      color: #404040;
      background-color: #e7e7e7;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      line-height: 1;
      text-decoration: none;
      text-overflow: ellipsis;
      overflow: hidden;
      text-transform: uppercase;
      -webkit-transition: background-color .2s;
      transition: background-color .2s;
      vertical-align: middle;
      white-space: nowrap;
    }
    .viewcode-button:visited {
      color: #404040;
    }
    .viewcode-button:hover, .viewcode-button:focus {
      color: #404040;
      background-color: #d6d6d6;
    }
  </style>


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Airflow
          

          
          </a>

          
            
            
              <div class="version">
                1.10.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="project.html">프로젝트(Project)</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">라이센스(License)</a></li>
<li class="toctree-l1"><a class="reference internal" href="start.html">빠른 시작(Quick Start)</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">설치</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">튜토리얼(Tutorial)</a></li>
<li class="toctree-l1"><a class="reference internal" href="howto/index.html">사용 가이드</a></li>
<li class="toctree-l1"><a class="reference internal" href="ui.html">UI / 스크린샷(Screenshots)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">개념</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#core-ideas">핵심 개념</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dags">방향성 비순환 그래프(DAGs)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#scope">범위</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-arguments">기본 인수값</a></li>
<li class="toctree-l4"><a class="reference internal" href="#context-manager">컨텍스트 관리자</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#operators">오퍼레이터</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dag-assignment">DAG 할당</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bitshift-composition">비트쉬프트 구성</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tasks">태스크</a></li>
<li class="toctree-l3"><a class="reference internal" href="#task-instances">태스크 인스턴스</a></li>
<li class="toctree-l3"><a class="reference internal" href="#task-lifecycle">태스크 주기</a></li>
<li class="toctree-l3"><a class="reference internal" href="#workflows">워크플로우</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#additional-functionality">추가적인 기능</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hooks">훅(Hooks)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pools">풀(Pools)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connections">커넥션</a></li>
<li class="toctree-l3"><a class="reference internal" href="#queues">대기열(Queues)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xcoms">XComs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variables">변수</a></li>
<li class="toctree-l3"><a class="reference internal" href="#branching">브랜치</a></li>
<li class="toctree-l3"><a class="reference internal" href="#subdags">서브 DAG</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slas">SLAs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#email-configuration">이메일 설정</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#trigger-rules">트리거 규칙</a></li>
<li class="toctree-l3"><a class="reference internal" href="#latest-run-only">최근 실행된 태스크</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zombies-undeads">좀비와 완전히 죽지 않은 태스크</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cluster-policy">클러스터 정책</a></li>
<li class="toctree-l3"><a class="reference internal" href="#documentation-notes">문서와 노트</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Jinja 템플릿</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#packaged-dags">패키지 된 DAG</a></li>
<li class="toctree-l2"><a class="reference internal" href="#airflowignore">.airflowignore</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command Line Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheduler.html">스케쥴링(Scheduling)&amp; 트리거(Triggers)</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugins.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="security.html">보안</a></li>
<li class="toctree-l1"><a class="reference internal" href="timezone.html">타임 존(Time zones)</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Experimental Rest API</a></li>
<li class="toctree-l1"><a class="reference internal" href="integration.html">Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="metrics.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="kubernetes.html">Kubernetes</a></li>
<li class="toctree-l1"><a class="reference internal" href="lineage.html">Lineage</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="macros.html">Macros reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="_api/index.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Airflow</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>개념</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/concepts.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="concepts">
<h1>개념<a class="headerlink" href="#concepts" title="제목 주소">¶</a></h1>
<p>에어플로우 플랫폼은 워크플로우를 설명하고, 실행하고, 모니터링할 수 있는 도구이다.</p>
<div class="section" id="core-ideas">
<h2>핵심 개념<a class="headerlink" href="#core-ideas" title="제목 주소">¶</a></h2>
<div class="section" id="dags">
<h3>방향성 비순환 그래프(DAGs)<a class="headerlink" href="#dags" title="제목 주소">¶</a></h3>
<p>에어플로우 에서, <code class="docutils literal notranslate"><span class="pre">DAG</span></code> -- 또는 방향성 비순환 그래프 --는 실행시키고 싶은 모든 태스크의 모음이며, 서로 간의 관계와 의존성을 반영하여 구조화한 것이다.</p>
<p>예를 들어, 간단한 DAG는 3가지의 태스크: A, B 그리고 C로 구성될 수 있다. A는 B가 실행하기 전에 성공적으로 작업을 마쳐야 하지만, C는 아무때나 실행할 수 있다. 5분 후 태스크 A의 시간이 끝나고, B는 실패할 경우에 최대 5회까지 다시 시작될 수 있다. 또한 워크플로우가 매일 밤 10시에 실행될 예정이지만, 특정 날짜 전에는 시작하지 않도록 할 수 있다.</p>
<p>이런 식으로, DAG는 <em>어떻게</em> 워크플로우를 실행하길 원하는지 설명한다; 하지만 <em>무엇을</em> 실제로 하고 싶은지에 대해서는 아무것도 말하지 않았다는 것을 주목해라! A, B 그리고 C는 무엇이든 할 수 있다. 아마 A는 B가 분석할 데이터를 준비하는 반면 C는 메일을 보낼 것이다. 또는 A가 당신의 위치를 모니터링해서 B가 차고 문을 열 수 있도록 하는 동안 C는 당신의 집의 불을 켜고 있을 수 있다. 중요한 점은 DAG는 태스크가 할 일이 어떻게 구성되어 있는지 관심 없다는 것이다. DAG의 일은 동시에 어떤 일이 벌어지든 간에, 적시에, 올바른 순서로, 또는 예기치 못한 이슈를 올바르게 처리하도록 하는 것이다.</p>
<p>DAG는 기본 파이썬 파일 안에서 정의되고, 이 파일은 에어플로우의 <code class="docutils literal notranslate"><span class="pre">DAG_FOLDER</span></code> 안에 위치한다. 에어플로우는 <code class="docutils literal notranslate"><span class="pre">DAG</span></code> 객체를 동적으로 빌드하기 위한 각 파일 안의 코드를 실행한다. 원하는 만큼의 많은 DAG를 가질 수 있고, 각각은 임의의 개수만큼의 태스크를 설명하게 된다. 일반적으로, 각 DAG 하나는 단일 논리 워크플로우에 대응되어야 한다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">DAG를 찾을 때, 에어플로우는 기본적으로 “airflow” 그리고 “DAG” 문자열을 포함하는 파이썬 파일만을 고려한다. 모든 파이썬 파일을 고려하고 싶다면, <code class="docutils literal notranslate"><span class="pre">DAG_DISCOVERY_SAFE_MODE</span></code> 설정 플래그를 비활성화하라.</p>
</div>
<div class="section" id="scope">
<h4>범위<a class="headerlink" href="#scope" title="제목 주소">¶</a></h4>
<p>에어플로우는 DAG파일에서 임포트할 수 있는 모든 <code class="docutils literal notranslate"><span class="pre">DAG</span></code> 객체를 로드할 것이다. 정확히 말하면, DAG는 <code class="docutils literal notranslate"><span class="pre">globals()</span></code>안 에 있어야만 한다. 다음의 두 개의 DAG를 보자. 여기서 오직 <code class="docutils literal notranslate"><span class="pre">dag_1</span></code>만이 로드될 것이다; 다른 DAG는 로컬 범위 안에서만 나타난다.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dag_1</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="s1">&#39;this_dag_will_be_discovered&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
    <span class="n">dag_2</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="s1">&#39;but_this_dag_will_not&#39;</span><span class="p">)</span>

<span class="n">my_function</span><span class="p">()</span>
</pre></div>
</div>
<p>가끔 이것은 좋은 방법이 될 수 있다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">SubDagOperator</span></code>를 사용한 일반적인 패턴은 함수 내부에 서브dag를 정의하는데 에어플로우는 이것을 standalone DAG로 로드하려는 시도를 하지 않는다.</p>
</div>
<div class="section" id="default-arguments">
<h4>기본 인수값<a class="headerlink" href="#default-arguments" title="제목 주소">¶</a></h4>
<p>만약 <code class="docutils literal notranslate"><span class="pre">default_args</span></code>의 딕셔너리가 DAG로 전달된다면, DAG의 모든 오퍼레이터에 그 값들이 적용될 것이다. 이것은 많은 오퍼레이터에 여러 번 입력하지 않고도 공통 인수를 적용하기 쉽게 만든다.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">default_args</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;start_date&#39;</span><span class="p">:</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s1">&#39;owner&#39;</span><span class="p">:</span> <span class="s1">&#39;Airflow&#39;</span>
<span class="p">}</span>

<span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="s1">&#39;my_dag&#39;</span><span class="p">,</span> <span class="n">default_args</span><span class="o">=</span><span class="n">default_args</span><span class="p">)</span>
<span class="n">op</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">owner</span><span class="p">)</span> <span class="c1"># Airflow</span>
</pre></div>
</div>
</div>
<div class="section" id="context-manager">
<h4>컨텍스트 관리자<a class="headerlink" href="#context-manager" title="제목 주소">¶</a></h4>
<p><em>에어플로우 1.8에서 추가</em></p>
<p>DAG는 새로운 오퍼레이터를 DAG에 자동적으로 할당하는 컨텍스트 관리자로도 사용이 가능하다.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">DAG</span><span class="p">(</span><span class="s1">&#39;my_dag&#39;</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">as</span> <span class="n">dag</span><span class="p">:</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="s1">&#39;op&#39;</span><span class="p">)</span>

<span class="n">op</span><span class="o">.</span><span class="n">dag</span> <span class="ow">is</span> <span class="n">dag</span> <span class="c1"># True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="operators">
<span id="concepts-operators"></span><h3>오퍼레이터<a class="headerlink" href="#operators" title="제목 주소">¶</a></h3>
<p>DAG가 <em>어떻게</em> 워크플로우를 실행하는지 설명하는 반면, <code class="docutils literal notranslate"><span class="pre">Operators</span></code>는 실제로 어떤 작업을 수행할지 결정한다.</p>
<p>오퍼레이터는 워크플로우의 단일 태스크를 설명한다. 오퍼레이터는 (항상 그런 것은 아니지만) 대개 원자성(atomic)을 가지는데, 이는 독립적으로 실행할 수 있고 다른 오퍼레이터와 리소스를 공유할 필요가 없다는 의미이다. DAG는 오퍼레이터가 정확하고 특정한 순서에 따라 실행될 수 있도록 보장한다; 그러한 의존성 외에 오퍼레이터는 보통 독립적으로 운영된다. 사실상, 오퍼레이터는 완전히 다른 두 개의 머신에서 작동할 수도 있다.</p>
<p>이것은 미묘하지만 굉장히 중요한 점이다: 보통, 두 개의 오퍼레이터가 파일 이름이나 작은 양의 데이터 등의 정보를 공유한다고 했을 때, 이것들을 하나의 오퍼레이터로 결합하는 것을 고민해볼 수 있다. 이런 상황을 절대적으로 피할 수 없다면, 에어플로우가 가진 XCom이라는 이름의 오퍼레이터의 상호 통신 기능이 있는데, 이 문서의 다른 부분에서 설명한다.</p>
<p>에어플로우는 많은 공통적 태스크를 위한 오퍼레이터를 제공하는데, 다음을 포함한다:</p>
<ul class="simple">
<li><a class="reference internal" href="_api/airflow/operators/bash_operator/index.html#airflow.operators.bash_operator.BashOperator" title="airflow.operators.bash_operator.BashOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BashOperator</span></code></a> - bash 명령어를 실행</li>
<li><a class="reference internal" href="_api/airflow/operators/python_operator/index.html#airflow.operators.python_operator.PythonOperator" title="airflow.operators.python_operator.PythonOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">PythonOperator</span></code></a> - 임의의 파이썬 함수를 호출</li>
<li><a class="reference internal" href="_api/airflow/operators/email_operator/index.html#airflow.operators.email_operator.EmailOperator" title="airflow.operators.email_operator.EmailOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailOperator</span></code></a> - 이메일 전송</li>
<li><a class="reference internal" href="_api/airflow/operators/http_operator/index.html#airflow.operators.http_operator.SimpleHttpOperator" title="airflow.operators.http_operator.SimpleHttpOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleHttpOperator</span></code></a> - HTTP request를 전송</li>
<li><a class="reference internal" href="_api/airflow/operators/mysql_operator/index.html#airflow.operators.mysql_operator.MySqlOperator" title="airflow.operators.mysql_operator.MySqlOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MySqlOperator</span></code></a>, <a class="reference internal" href="_api/airflow/operators/sqlite_operator/index.html#airflow.operators.sqlite_operator.SqliteOperator" title="airflow.operators.sqlite_operator.SqliteOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SqliteOperator</span></code></a>, <a class="reference internal" href="_api/airflow/operators/postgres_operator/index.html#airflow.operators.postgres_operator.PostgresOperator" title="airflow.operators.postgres_operator.PostgresOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">PostgresOperator</span></code></a>, <a class="reference internal" href="_api/airflow/operators/mssql_operator/index.html#airflow.operators.mssql_operator.MsSqlOperator" title="airflow.operators.mssql_operator.MsSqlOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MsSqlOperator</span></code></a>, <a class="reference internal" href="_api/airflow/operators/oracle_operator/index.html#airflow.operators.oracle_operator.OracleOperator" title="airflow.operators.oracle_operator.OracleOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">OracleOperator</span></code></a>, <a class="reference internal" href="_api/airflow/operators/jdbc_operator/index.html#airflow.operators.jdbc_operator.JdbcOperator" title="airflow.operators.jdbc_operator.JdbcOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">JdbcOperator</span></code></a>, etc. - SQL 명령어 실행</li>
<li><code class="docutils literal notranslate"><span class="pre">Sensor</span></code> - 특정 시간, 파일, 데이터베이스 행, S3키 기타 등등…</li>
</ul>
<p>이러한 기본적인 구성 요소 외에도, 더 많은 수의 특정 오퍼레이터들이 있다: <a class="reference internal" href="_api/airflow/operators/docker_operator/index.html#airflow.operators.docker_operator.DockerOperator" title="airflow.operators.docker_operator.DockerOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">DockerOperator</span></code></a>, <a class="reference internal" href="_api/airflow/operators/hive_operator/index.html#airflow.operators.hive_operator.HiveOperator" title="airflow.operators.hive_operator.HiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">HiveOperator</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">S3FileTransformOperator(</span></code>, <a class="reference internal" href="_api/airflow/operators/presto_to_mysql/index.html#airflow.operators.presto_to_mysql.PrestoToMySqlTransfer" title="airflow.operators.presto_to_mysql.PrestoToMySqlTransfer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrestoToMySqlTransfer</span></code></a>, <a class="reference internal" href="_api/airflow/operators/slack_operator/index.html#airflow.operators.slack_operator.SlackAPIOperator" title="airflow.operators.slack_operator.SlackAPIOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SlackAPIOperator</span></code></a>… you get the idea!</p>
<p>오퍼레이터는 DAG에 할당되었을 경우에만 에어플로우에 의해 로드된다.</p>
<p>에어플로우 오퍼레이터를 어떻게 사용하는지는 <a class="reference internal" href="howto/operator/index.html"><span class="doc">오퍼레이터 사용</span></a>를 보라.</p>
<div class="section" id="dag-assignment">
<h4>DAG 할당<a class="headerlink" href="#dag-assignment" title="제목 주소">¶</a></h4>
<p><em>에어플로우 1.8에서 추가</em></p>
<p>오퍼레이터는 DAG에 즉시 할당할 필요가 없다(이전에는 <code class="docutils literal notranslate"><span class="pre">dag</span></code>가 필수 인자였다). 하지만, 오퍼레이터가 DAG에 할당되는 순간에, 오퍼레이터는 이동하거나 할당 해제될 수 없다. DAG 할당은 오퍼레이터가 생성됐을 때, 지연 할당을 통해, 또는 심지어 다른 오퍼레이터로부터 간접적으로 추론되었을 때에 명시적으로 이루어질 수 있다.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="s1">&#39;my_dag&#39;</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># sets the DAG explicitly</span>
<span class="n">explicit_op</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;op1&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>

<span class="c1"># deferred DAG assignment</span>
<span class="n">deferred_op</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;op2&#39;</span><span class="p">)</span>
<span class="n">deferred_op</span><span class="o">.</span><span class="n">dag</span> <span class="o">=</span> <span class="n">dag</span>

<span class="c1"># inferred DAG assignment (linked operators must be in the same DAG)</span>
<span class="n">inferred_op</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;op3&#39;</span><span class="p">)</span>
<span class="n">inferred_op</span><span class="o">.</span><span class="n">set_upstream</span><span class="p">(</span><span class="n">deferred_op</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="bitshift-composition">
<h4>비트쉬프트 구성<a class="headerlink" href="#bitshift-composition" title="제목 주소">¶</a></h4>
<p><em>에어플로우 1.8에서 추가</em></p>
<p>전통적으로, 오퍼레이터 관계는 <code class="docutils literal notranslate"><span class="pre">set_upstream()</span></code>과 <code class="docutils literal notranslate"><span class="pre">set_downstream()</span></code> 메소드로 설정된다. 에어플로우 1.8에서는 파이썬 비트쉬프트 연산자인 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>과 <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>로 할 수 있다. 아래 4개의 표현은 모두 기능적으로 동일하다:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">&gt;&gt;</span> <span class="n">op2</span>
<span class="n">op1</span><span class="o">.</span><span class="n">set_downstream</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>

<span class="n">op2</span> <span class="o">&lt;&lt;</span> <span class="n">op1</span>
<span class="n">op2</span><span class="o">.</span><span class="n">set_upstream</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>
</pre></div>
</div>
<p>비트쉬프트를 사용하여 오퍼레이터를 구성할 때, 관계는 비트쉬프트 오퍼레이터 포인트의 방향에 따라 설정된다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">op1</span> <span class="pre">&gt;&gt;</span> <span class="pre">op2</span></code>는 <code class="docutils literal notranslate"><span class="pre">op1</span></code>이 먼저 실행되고 <code class="docutils literal notranslate"><span class="pre">op2</span></code>가 두번째로 실행된다는 것을 의미한다. 여러 오퍼레이터들은 조합될 수 있는데 — 이러한 체인은 왼쪽에서 부터 오른쪽으로 실행되고, 가장 오른쪽의 객체가 항상 리턴된다는 것을 기억하라. 아래는 예시이다:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">&gt;&gt;</span> <span class="n">op2</span> <span class="o">&gt;&gt;</span> <span class="n">op3</span> <span class="o">&lt;&lt;</span> <span class="n">op4</span>
</pre></div>
</div>
<p>이것은 다음과 동일하다:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span><span class="o">.</span><span class="n">set_downstream</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>
<span class="n">op2</span><span class="o">.</span><span class="n">set_downstream</span><span class="p">(</span><span class="n">op3</span><span class="p">)</span>
<span class="n">op3</span><span class="o">.</span><span class="n">set_upstream</span><span class="p">(</span><span class="n">op4</span><span class="p">)</span>
</pre></div>
</div>
<p>편의성을 위해, 비트쉬프트 오퍼레이터는 DAG에서도 사용이 가능하다. 예를 보자:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dag</span> <span class="o">&gt;&gt;</span> <span class="n">op1</span> <span class="o">&gt;&gt;</span> <span class="n">op2</span>
</pre></div>
</div>
<p>이것은 다음과 동일하다:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span><span class="o">.</span><span class="n">dag</span> <span class="o">=</span> <span class="n">dag</span>
<span class="n">op1</span><span class="o">.</span><span class="n">set_downstream</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>
</pre></div>
</div>
<p>간단한 파이프라인을 만들기 위해 이러한 모든 것을 사용할 수 있다:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">DAG</span><span class="p">(</span><span class="s1">&#39;my_dag&#39;</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">as</span> <span class="n">dag</span><span class="p">:</span>
    <span class="p">(</span>
        <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;dummy_1&#39;</span><span class="p">)</span>
        <span class="o">&gt;&gt;</span> <span class="n">BashOperator</span><span class="p">(</span>
            <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;bash_1&#39;</span><span class="p">,</span>
            <span class="n">bash_command</span><span class="o">=</span><span class="s1">&#39;echo &quot;HELLO!&quot;&#39;</span><span class="p">)</span>
        <span class="o">&gt;&gt;</span> <span class="n">PythonOperator</span><span class="p">(</span>
            <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;python_1&#39;</span><span class="p">,</span>
            <span class="n">python_callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;GOODBYE!&quot;</span><span class="p">))</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>또한 비트쉬프트는 리스트와 함께 사용될 수도 있다. 예를 들어:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">&gt;&gt;</span> <span class="p">[</span><span class="n">op2</span><span class="p">,</span> <span class="n">op3</span><span class="p">]</span>
</pre></div>
</div>
<p>이것은 다음과 동일하다:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">&gt;&gt;</span> <span class="n">op2</span>
<span class="n">op1</span> <span class="o">&gt;&gt;</span> <span class="n">op3</span>
</pre></div>
</div>
<p>이것은 다음과 동일하다:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span><span class="o">.</span><span class="n">set_downstream</span><span class="p">([</span><span class="n">op2</span><span class="p">,</span> <span class="n">op3</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="tasks">
<h3>태스크<a class="headerlink" href="#tasks" title="제목 주소">¶</a></h3>
<p>오퍼레이터가 인스턴스화 되었을 때, 이를 “task”라고 부른다. 인스턴스화란 추상적 오퍼레이터를 호출할 때 특정한 값을 정의하며, 매개변수화된 태스크는 DAG 안의 노드가 된다.</p>
</div>
<div class="section" id="task-instances">
<h3>태스크 인스턴스<a class="headerlink" href="#task-instances" title="제목 주소">¶</a></h3>
<p>태스크 인스턴스는 태스크의 특정한 실행을 나타내고 DAG, 태스크 그리고 특정 시점의 조합으로 특정지어 진다. 태스크 인스턴스는 또한 “running”, “success”, “failed”, “skipped”, “up for retry”, 등으로 상태를 나타낸다.</p>
</div>
<div class="section" id="task-lifecycle">
<h3>태스크 주기<a class="headerlink" href="#task-lifecycle" title="제목 주소">¶</a></h3>
<p>태스크는 시작부터 완료까지 다양한 단계를 지난다. 에어플로우 UI(그래프와 트리 뷰)에서는, 각각의 상태가 색깔로 표시되어 보여진다:</p>
<img alt="_images/task_lifecycle.png" src="_images/task_lifecycle.png" />
<p>행복한 상태의 흐름은 다음의 단계들로 구성된다:</p>
<ol class="arabic simple">
<li>상태 없음(스케쥴러에서 빈 태스크 인스턴스 생성)</li>
<li>대기 상태(스케쥴러가 실행할 태스크를 대기열에 배치)</li>
<li>실행 상태(워커가 태스크를 선택하고 실행중)</li>
<li>성공 상태(태스크 완료)</li>
</ol>
<p>또한 예약된 DAG/태스크와 수동으로 트리거된 DAG/태스크 사이에는 시각적인 차이가 있다:</p>
<img alt="_images/task_manual_vs_scheduled.png" src="_images/task_manual_vs_scheduled.png" />
<p>검정 선으로 된 DAG/태스크는 예약되어 실행한 것인 반면, 선이 없는 DAG/태스크는 수동으로 트리거된 것, 즉 <cite>airflow trigger_dag</cite>에 의해 실행된 것이다.</p>
</div>
<div class="section" id="workflows">
<h3>워크플로우<a class="headerlink" href="#workflows" title="제목 주소">¶</a></h3>
<p>이제 에어플로우의 기본 요소들에 익숙해졌다. 몇가지의 개념은 매우 비슷해 보이지만, 개념적인 용어는 다음과 같다:</p>
<ul class="simple">
<li>DAG: 작업이 수행되어야 하는 순서에 대한 설명</li>
<li>오퍼레이터: 어떤 작업을 수행하기 위한 템플릿으로서 역할을 하는 클래스</li>
<li>태스크: 오퍼레이터의 매개변수화된 인스턴스</li>
<li>태스크 인스턴스: 1) DAG로 할당된 태스크이고 2) DAG의 특정 수행와 연관된 상태를 가진 태스크</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">DAGs</span></code>와 <code class="docutils literal notranslate"><span class="pre">Operators</span></code>를 결합하여 <code class="docutils literal notranslate"><span class="pre">TaskInstances</span></code>를 생성하면 복잡한 워크플로우를 만들 수 있다.</p>
</div>
</div>
<div class="section" id="additional-functionality">
<h2>추가적인 기능<a class="headerlink" href="#additional-functionality" title="제목 주소">¶</a></h2>
<p>에어플로우 객체외에도, 리소스에 동시 접근 제한, 상호 통신, 조건부 실행 등의 작동을 할 수 있는 여러 가지 복잡한 기능이 있다.</p>
<div class="section" id="hooks">
<h3>훅(Hooks)<a class="headerlink" href="#hooks" title="제목 주소">¶</a></h3>
<p>훅은 외부 플랫폼과 Hive, S3, MySQL, Postgres, HDFS 그리고 Pig와 같은 데이터베이스 사이의 인터페이스이다. 훅은 가능하면 공통된 인터페이스를 구현하고, 오퍼레이터를 위한 기본 요소로서 동작한다. 또한 <code class="docutils literal notranslate"><span class="pre">airflow.models.connection.Connection</span></code> 모델을 이용하여 호스트이름과 인증 정보를 검색한다. 훅은 인증 코드와 정보를 메타데이터 데이터베이스 안에 중앙 집중화된 파이프라인으로 보관한다.</p>
<p>또한 훅은 Airflow airflow.operators.PythonOperator와 같은 파이썬 스크립트와 iPython이나 Jupyter Notebook과 같은 인터랙티브 환경에서 사용하기에 매우 유용하다.</p>
</div>
<div class="section" id="pools">
<h3>풀(Pools)<a class="headerlink" href="#pools" title="제목 주소">¶</a></h3>
<p>일부 시스템들은 너무나 많은 프로세스가 동시에 작동될 때 여기에 압도될 수 있다. 에어플로우 풀은 임의의 태스크 집합에서 <strong>병렬적 실행 제한</strong>을 사용할 수 있다. 풀의 목록은 풀의 이름을 정하고 여러 워커(worker) 슬롯(slot)에 할당하여 UI(<code class="docutils literal notranslate"><span class="pre">Menu</span> <span class="pre">-&gt;</span> <span class="pre">Admin</span> <span class="pre">-&gt;</span> <span class="pre">Pools</span></code>)에서 관리한다. 그 다음 태스크(즉, 인스턴스화된 오퍼레이터)가 생성될 때 <code class="docutils literal notranslate"><span class="pre">pool</span></code> 매개변수를 사용하여 기존에 있는 풀 중 하나와 연결될 수 있다.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">aggregate_db_message_job</span> <span class="o">=</span> <span class="n">BashOperator</span><span class="p">(</span>
    <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;aggregate_db_message_job&#39;</span><span class="p">,</span>
    <span class="n">execution_timeout</span><span class="o">=</span><span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
    <span class="n">pool</span><span class="o">=</span><span class="s1">&#39;ep_data_pipeline_db_msg_agg&#39;</span><span class="p">,</span>
    <span class="n">bash_command</span><span class="o">=</span><span class="n">aggregate_db_message_job_cmd</span><span class="p">,</span>
    <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>
<span class="n">aggregate_db_message_job</span><span class="o">.</span><span class="n">set_upstream</span><span class="p">(</span><span class="n">wait_for_empty_queue</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pool</span></code> 파라미터는 <code class="docutils literal notranslate"><span class="pre">priority_weight</span></code>와 함께 사용되어 대기열(queue) 내의 우선 순위와 풀에서 슬롯이 열리면 어떤 태스크가 처음으로 실행될지를 결정할 수 있다. <code class="docutils literal notranslate"><span class="pre">priority_weight</span></code>의 기본값은 <code class="docutils literal notranslate"><span class="pre">1</span></code>이고, 아무 숫자나 될 수 있다. 어떤 태스크가 다음에 실행되어야 할지 계산하기 위해 대기열을 정렬할 때, <code class="docutils literal notranslate"><span class="pre">priority_weight</span></code>을 사용하는데, 이는 이번 태스크의 다운스트림에 있는 태스크의 모든 <code class="docutils literal notranslate"><span class="pre">priority_weight</span></code> 값으로 요약된 것이다. 이를 이용하여 특정한 중요 태스크를 처리할 수 있고, 그 태스크에 대한 전체 경로가 우선 순위에 맞게 정해진다.</p>
<p>슬롯이 채워지는 동안 태스크는 평상시와 같이 스케쥴링 될 것이다. 슬롯이 모두 차면 실행 중인 태스크는 대기되고 해당 태스크의 상태가 UI에서 보이게 될 것이다. 슬롯이 비워지면, 대기중이던 태스크가 (태스크와 그 자식 태스크들의) <code class="docutils literal notranslate"><span class="pre">priority_weight</span></code>를 기준으로 다시 실행되기 시작한다.</p>
<p>기본적으로 태스크는 어떠한 풀에도 할당되지 않고, 그 태스크들의 병렬적 실행이 실행자의 설정에 따라 제한되는 것을 유의하라.</p>
<p>풀과 서브 DAG의 조합은 <a class="reference internal" href="#subdags">SubDAGs</a> 부분을 보라.</p>
</div>
<div class="section" id="connections">
<span id="concepts-connections"></span><h3>커넥션<a class="headerlink" href="#connections" title="제목 주소">¶</a></h3>
<p>외부 시스템과의 커넥션 정보는 에어플로우 메타데이터 데이터베이스에 저장되고 UI(<code class="docutils literal notranslate"><span class="pre">Menu</span> <span class="pre">-&gt;</span> <span class="pre">Admin</span> <span class="pre">-&gt;</span> <span class="pre">Connections</span></code>)에서 관리된다. <code class="docutils literal notranslate"><span class="pre">conn_id</span></code>는 거기서 정의되고 여기에 호스트이름 / 로그인 / 암호 / 스키마 정보가 첨부된다. 에어플로우 파이프라인은 이러한 정보를 아무데서나 하드 코딩할 필요 없이 중앙 관리되는 <code class="docutils literal notranslate"><span class="pre">conn_id</span></code>를 간단히 참조할 수 있다.</p>
<p>동일한 <code class="docutils literal notranslate"><span class="pre">conn_id</span></code>를 가진 여러 커넥션들이 정의될 수 있고, 그런 경우와 <strong>hooks</strong>이 <code class="docutils literal notranslate"><span class="pre">BaseHook</span></code>의 <code class="docutils literal notranslate"><span class="pre">get_connection</span></code> 메소드를 사용할 때 에어플로우는 무작위적으로 하나의 커넥션만 선택하고, 연결을 재시도할 때 기본적인 로드 밸런싱과 장애 허용 범위를 어느 정도 허용하게 된다.</p>
<p>또한 에어플로우는 운영체제의 환경 변수를 통해 커넥션을 참조하는 기능이 있다. 이 때 커넥션 파라미터는 URI 포맷으로 저장되어 있어야만 한다.</p>
<p>만약 동일한 <code class="docutils literal notranslate"><span class="pre">conn_id</span></code>를 가진 커넥션들이 에어플로우 메타데이터 데이터베이스와 환경 변수 둘 다로 정의되었다면, 환경 변수에 있는 것만 에어플로우에 의해 참조될 것이다(예를 들어, <code class="docutils literal notranslate"><span class="pre">conn_id</span></code> <code class="docutils literal notranslate"><span class="pre">postgres_master</span></code>가 주어졌을 때, 에어플로우는 메타데이터 데이터베이스에서 검색을 시작하기 전에, 먼저 환경 변수 안의 <code class="docutils literal notranslate"><span class="pre">AIRFLOW_CONN_POSTGRES_MASTER</span></code>를 찾아보고 이를 직접적으로 참조한다).</p>
<p>대부분의 훅은 기본값인 <code class="docutils literal notranslate"><span class="pre">conn_id</span></code>를 가지는데, 그 훅들을 사용하는 오퍼레이터들은 명시적 커넥션 ID를 제공할 필요가 없다. 예를 들어, <a class="reference internal" href="_api/airflow/hooks/postgres_hook/index.html#airflow.hooks.postgres_hook.PostgresHook" title="airflow.hooks.postgres_hook.PostgresHook"><code class="xref py py-class docutils literal notranslate"><span class="pre">PostgresHook</span></code></a>를 위한 기본값인 <code class="docutils literal notranslate"><span class="pre">conn_id</span></code>은 <code class="docutils literal notranslate"><span class="pre">postgres_default</span></code>이다.</p>
<p>커넥션을 어떻게 생성하고 관리하는지는 <a class="reference internal" href="howto/connection/index.html"><span class="doc">커넥션(Connection) 관리</span></a>을 보라.</p>
</div>
<div class="section" id="queues">
<h3>대기열(Queues)<a class="headerlink" href="#queues" title="제목 주소">¶</a></h3>
<p>CeleryExecutor를 사용할 때, 태스크가 전송되는 셀러리의 대기열을 지정할 수 있다. <code class="docutils literal notranslate"><span class="pre">queue</span></code>은 BaseOperator의 속성이기 때문에, 어떤 태스크도 아무 대기열에 할당될 수 있다. 환경에서 기본 대기열은 <code class="docutils literal notranslate"><span class="pre">airflow.cfg</span></code>의 <code class="docutils literal notranslate"><span class="pre">celery</span> <span class="pre">-&gt;</span> <span class="pre">defalut_queue</span></code>에 정의되어 있다. 이는 지정되지 않았을 때 태스크가 할당되는 대기열뿐만 아니라, 시작할 때 에어플로우 워커가 주목하는 대기열을 정의한다.</p>
<p>워커들은 하나 또는 여러 개의 태스크 대기열을 listen 할 수 있다. (<code class="docutils literal notranslate"><span class="pre">airflow</span> <span class="pre">worker</span></code> 명령어를 사용하여) 워커가 시작될 때, 쉼표로 구분된 대기열 이름의 집합을 지정할 수 있다(예를 들어 <code class="docutils literal notranslate"><span class="pre">airflow</span> <span class="pre">worker</span> <span class="pre">-q</span> <span class="pre">spark</span></code>). 그럼 이 워커는 지정된 대기열에서 연결된 태스크만 선택할 것이다.</p>
<p>이는 특화된 워커가 필요하거나, 자원 관점에서(하나의 워커가 수천 개의 태스크를 문제 없이 수행할 만큼 매우 가벼운 태스크인 경우), 또는 환경 관점에서(매우 구체적인 환경과 보안 권한의 이유로 워커가 Sparl 클러스터 내에서 스스로 실행되기를 원할 때) 유용할 수 있다.</p>
</div>
<div class="section" id="xcoms">
<h3>XComs<a class="headerlink" href="#xcoms" title="제목 주소">¶</a></h3>
<p>XComs은 태스크 사이의 메세지를 교환하게 하고, 제어와 공유 상태의 미묘한 형태를 가능하게 한다. 이름은 “cross-communication”의 약칭이다. XComs은 주로 키, 값(value) 그리고 타임스탬프에 의해 정의되지만, XCom을 만든 태스크/DAG와 같은 속성과 언제 보여지는지에 따라 정의되기도 한다. 피클링 될 수 있는 객체는 XCom 값으로 사용될 수 있고, 따라서 사용자는 적절한 크기의 객체를 사용하는지 확실히 해야 한다.</p>
<p>XComs은 “pushed” (전송) 또는 “pulled” (수신)될 수 있다. 태스크가 XCom을 push히면, 일반적으로 다른 태스크에 사용 가능하게 된다. 태스크는 <code class="docutils literal notranslate"><span class="pre">xcom_push</span></code> 메소드를 호출함으로써 아무때나 XComs을 push 할 수 있다. 추가적으로, 태스크가 어떤 값을 반환하면(오퍼레이터의 <code class="docutils literal notranslate"><span class="pre">execute()</span></code> 메소드로부터 반환거나 또는 PythonOperator의 <code class="docutils literal notranslate"><span class="pre">python__callable</span></code> 함수로부터 반환됐을 경우), XCom은 그 값을 포함하여 자동적으로 push된다.</p>
<p>태스크는 XComs을 검색하기 위해 <code class="docutils literal notranslate"><span class="pre">xcom_pull()</span></code>을 호출하고, <code class="docutils literal notranslate"><span class="pre">key</span></code>, 소스(source)의 <code class="docutils literal notranslate"><span class="pre">task_ids</span></code>, 그리고 소스의 <code class="docutils literal notranslate"><span class="pre">dag_id</span></code>와 같은 기준에 따라 선택적으로 필터를 적용한다. 기본적으로 XComs가 실행 함수에서 반환되는 키를 push할 때 (수동으로 push되는 XComs과는 반대로) XComs에 자동으로 주어지는 키에 대한 <code class="docutils literal notranslate"><span class="pre">xcom_pull()</span></code> 필터는 다음과 같다.</p>
<p>만약 <code class="docutils literal notranslate"><span class="pre">xcom_pull</span></code>이 <code class="docutils literal notranslate"><span class="pre">task_ids</span></code>에 대한 단일 문자열을 전달받으면, 해당 태스크에 대한 가장 최근의 XCom 값이 반환된다; 만약 <code class="docutils literal notranslate"><span class="pre">task_ids</span></code> 리스트가 전달되면, XCom 값의 관련 리스트가 반환된다.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># inside a PythonOperator called &#39;pushing_task&#39;</span>
<span class="k">def</span> <span class="nf">push_function</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="c1"># inside another PythonOperator where provide_context=True</span>
<span class="k">def</span> <span class="nf">pull_function</span><span class="p">(</span><span class="o">**</span><span class="n">context</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s1">&#39;task_instance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">xcom_pull</span><span class="p">(</span><span class="n">task_ids</span><span class="o">=</span><span class="s1">&#39;pushing_task&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>템플릿에서 XCom을 직접적으로 pull하는 것도 가능하며, 다음과 같은 예를 들 수 있다:</p>
<div class="code jinja highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="p">{{</span> <span class="n">task_instance</span><span class="o">.</span><span class="n">xcom_pull</span><span class="p">(</span><span class="n">task_ids</span><span class="o">=</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;table_name&#39;</span><span class="p">)</span> <span class="p">}}</span>
</pre></div>
</div>
<p>XComs은 <a class="reference internal" href="#variables">Variables</a>와 비슷하지만, 글로벌 설정보다 내부-태스크 커뮤니케이션을 위해 특징적으로 설계되어 있는 점에 유의하라.</p>
</div>
<div class="section" id="variables">
<h3>변수<a class="headerlink" href="#variables" title="제목 주소">¶</a></h3>
<p>변수들은 에어플로우에서 간단한 키 값으로 임의의 내용이나 설정을 저장하고 검색하는 일반적인 방법이다. 변수들은 UI(<code class="docutils literal notranslate"><span class="pre">Admin</span> <span class="pre">-&gt;</span> <span class="pre">Variable</span></code>), 코드 또는 CLI에서 목록화, 생성, 업데이트 그리고 삭제될 수 있다. 게다가, json 설정 파일을 UI를 통해 한꺼번에 대량으로 업로드할 수 있다. 파이프라인 코드 정의와 대부분의 상수 및 변수는 코드로써 정의되어 있고, 소스 제어에 저장되어야 하지만, UI를 통해 일부 변수 또는 구성 항목에 접근 가능하고 수정 가능한 것이 유용할 수 있다.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">airflow.models</span> <span class="k">import</span> <span class="n">Variable</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">Variable</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="n">bar</span> <span class="o">=</span> <span class="n">Variable</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="n">deserialize_json</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">baz</span> <span class="o">=</span> <span class="n">Variable</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;baz&quot;</span><span class="p">,</span> <span class="n">default_var</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>두번째 호출은 <code class="docutils literal notranslate"><span class="pre">json</span></code> 내용을 가정하고 <code class="docutils literal notranslate"><span class="pre">bar</span></code>로 구분될 것이다. <code class="docutils literal notranslate"><span class="pre">Variable</span></code>은 sqlalchemy 모델이고 이와 같이 사용될 수 있음에 유의하라. 세번째 호출은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 값인 <code class="docutils literal notranslate"><span class="pre">default_var</span></code> 파라미터를 사용하는데, 변수가 정의되어 있지 않았으면 현재 존재하는 값 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 리턴한다. 만일 변수가 존재하지 않고 기본값이 제공되지 않을 경우 get 함수는 <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>를 내보낸다.</p>
<p>Jinja 템플릿을 사용한 문법으로 변수를 사용할 수 있다:</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">echo</span> <span class="p">{{</span> <span class="n">var</span><span class="o">.</span><span class="n">value</span><span class="o">.&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">}}</span>
</pre></div>
</div>
<p>또는 변수로부터 json 객체를 구분한다:</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">echo</span> <span class="p">{{</span> <span class="n">var</span><span class="o">.</span><span class="n">json</span><span class="o">.&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">}}</span>
</pre></div>
</div>
</div>
<div class="section" id="branching">
<h3>브랜치<a class="headerlink" href="#branching" title="제목 주소">¶</a></h3>
<p>어떤 때에는 분기하기 위한 워크플로우가 필요하거나, 일반적으로 업스트림 태스크에서 일어난 일과 관련한 임의의 조건에 기반하여 특정 경로를 따라 가야한다. 이를 위한 한 가지 방법은 <code class="docutils literal notranslate"><span class="pre">BranchPythonOperator</span></code>를 사용하는 것이다.</p>
<p><code class="docutils literal notranslate"><span class="pre">BranchPythonOperator</span></code>는 task_id(또는 task_id의 목록)을 반환하는 <code class="docutils literal notranslate"><span class="pre">python_callable</span></code>을 기대한다는 점을 제외하고 PythonOperator와 매우 비슷하다. task_id는 다음과 같이 반환되는데, 모든 다른 경로는 건너뛴다. Python 함수에 의해 반환되는 task_id는 BranchPythonOperator 태스크로부터 직접 다운스트림 작업을 참조해야 한다.</p>
<p>경로가 반환된 태스크 (목록)의 다운스트림 태스크일 때, 이 경로는 건너 뛰지 않음을 유의하라:</p>
<img alt="_images/branch_note.png" src="_images/branch_note.png" />
<p>분기된 태스크의 경로는 <code class="docutils literal notranslate"><span class="pre">branch_a</span></code>, <code class="docutils literal notranslate"><span class="pre">join</span></code> 그리고 <code class="docutils literal notranslate"><span class="pre">branch_b</span></code>이다. <code class="docutils literal notranslate"><span class="pre">join</span></code>이 <code class="docutils literal notranslate"><span class="pre">branch_a</span></code>의 다운스트림 태스크이기 때문에, <code class="docutils literal notranslate"><span class="pre">branch_a</span></code>가 Python 호출에 의해 반환된 것일 때 생략되는 태스크에서 제외된다.</p>
<p><code class="docutils literal notranslate"><span class="pre">BranchPython</span> <span class="pre">Operator</span></code>는 XComs과 함께 사용이 가능한데 이전의 태스크에 기반하여 그 다음의 어떤 분기점을 가질지 동적으로 결정하는 분기 맥락을 허용한다. 예를 들면:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">branch_func</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">ti</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ti&#39;</span><span class="p">]</span>
    <span class="n">xcom_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">xcom_pull</span><span class="p">(</span><span class="n">task_ids</span><span class="o">=</span><span class="s1">&#39;start_task&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">xcom_value</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;continue_task&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;stop_task&#39;</span>

<span class="n">start_op</span> <span class="o">=</span> <span class="n">BashOperator</span><span class="p">(</span>
    <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;start_task&#39;</span><span class="p">,</span>
    <span class="n">bash_command</span><span class="o">=</span><span class="s2">&quot;echo 5&quot;</span><span class="p">,</span>
    <span class="n">xcom_push</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>

<span class="n">branch_op</span> <span class="o">=</span> <span class="n">BranchPythonOperator</span><span class="p">(</span>
    <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;branch_task&#39;</span><span class="p">,</span>
    <span class="n">provide_context</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">python_callable</span><span class="o">=</span><span class="n">branch_func</span><span class="p">,</span>
    <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>

<span class="n">continue_op</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;continue_task&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>
<span class="n">stop_op</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;stop_task&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>

<span class="n">start_op</span> <span class="o">&gt;&gt;</span> <span class="n">branch_op</span> <span class="o">&gt;&gt;</span> <span class="p">[</span><span class="n">continue_op</span><span class="p">,</span> <span class="n">stop_op</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="subdags">
<h3>서브 DAG<a class="headerlink" href="#subdags" title="제목 주소">¶</a></h3>
<p>서브 DAG는 패턴을 반복하기에 아주 좋다. DAG 객체를 반환하는 함수를 정의하는 것은 에어플로우를 사용할 때 아주 좋은 설계 패턴이다.</p>
<p>Airbnb는 데이터를 로딩할 때 <em>stage-check-exchange</em> 패턴을 사용한다. 데이터는 임시 테이블에서 준비되고, 이후 해당 테이블에 대해서 데이터 품질 검사를 실시한다. 검사가 모두 통과되면 해당 파티션이 프로덕션 테이블로 이동된다.</p>
<p>또 다른 예시로, 다음의 DAG를 보라:</p>
<img alt="_images/subdag_before.png" src="_images/subdag_before.png" />
<p>모든 병렬적 <code class="docutils literal notranslate"><span class="pre">task-*</span></code> 오퍼레이터를 단일 서브 DAG 내부로 결합하여 결과 DAG가 다음과 유사하도록 할 수 있다:</p>
<img alt="_images/subdag_after.png" src="_images/subdag_after.png" />
<p>서브 DAG 오퍼레이터는 DAG 객체를 반환하는 팩토리 메서드를 포함해야 함을 유의하라. 이는 서브DAG를 메인 UI에서 구분되어 있는 DAG처럼 다루는 것을 방지한다. 예를 들어 보자:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#dags/subdag.py</span>
<span class="kn">from</span> <span class="nn">airflow.models</span> <span class="k">import</span> <span class="n">DAG</span>
<span class="kn">from</span> <span class="nn">airflow.operators.dummy_operator</span> <span class="k">import</span> <span class="n">DummyOperator</span>


<span class="c1"># Dag is returned by a factory method</span>
<span class="k">def</span> <span class="nf">sub_dag</span><span class="p">(</span><span class="n">parent_dag_name</span><span class="p">,</span> <span class="n">child_dag_name</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">schedule_interval</span><span class="p">):</span>
  <span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span>
    <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parent_dag_name</span><span class="p">,</span> <span class="n">child_dag_name</span><span class="p">),</span>
    <span class="n">schedule_interval</span><span class="o">=</span><span class="n">schedule_interval</span><span class="p">,</span>
    <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span>
  <span class="p">)</span>

  <span class="n">dummy_operator</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span>
    <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;dummy_task&#39;</span><span class="p">,</span>
    <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">,</span>
  <span class="p">)</span>

  <span class="k">return</span> <span class="n">dag</span>
</pre></div>
</div>
<p>이 서브 DAG는 다음의 메인 DAG 파일에서 참조될 수 있다:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># main_dag.py</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">airflow.models</span> <span class="k">import</span> <span class="n">DAG</span>
<span class="kn">from</span> <span class="nn">airflow.operators.subdag_operator</span> <span class="k">import</span> <span class="n">SubDagOperator</span>
<span class="kn">from</span> <span class="nn">dags.subdag</span> <span class="k">import</span> <span class="n">sub_dag</span>


<span class="n">PARENT_DAG_NAME</span> <span class="o">=</span> <span class="s1">&#39;parent_dag&#39;</span>
<span class="n">CHILD_DAG_NAME</span> <span class="o">=</span> <span class="s1">&#39;child_dag&#39;</span>

<span class="n">main_dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span>
  <span class="n">dag_id</span><span class="o">=</span><span class="n">PARENT_DAG_NAME</span><span class="p">,</span>
  <span class="n">schedule_interval</span><span class="o">=</span><span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
  <span class="n">start_date</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">sub_dag</span> <span class="o">=</span> <span class="n">SubDagOperator</span><span class="p">(</span>
  <span class="n">subdag</span><span class="o">=</span><span class="n">sub_dag</span><span class="p">(</span><span class="n">PARENT_DAG_NAME</span><span class="p">,</span> <span class="n">CHILD_DAG_NAME</span><span class="p">,</span> <span class="n">main_dag</span><span class="o">.</span><span class="n">start_date</span><span class="p">,</span>
                 <span class="n">main_dag</span><span class="o">.</span><span class="n">schedule_interval</span><span class="p">),</span>
  <span class="n">task_id</span><span class="o">=</span><span class="n">CHILD_DAG_NAME</span><span class="p">,</span>
  <span class="n">dag</span><span class="o">=</span><span class="n">main_dag</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>메인 DAG의 그래프 보기에서 SubDagOperator를 확대하여 SubDAG 내에 포함되어 있는 태스크를 볼 수 있다:</p>
<img alt="_images/subdag_zoom.png" src="_images/subdag_zoom.png" />
<p>서브 DAG를 사용할 때의 다른 조언들:</p>
<ul class="simple">
<li>컨벤션에 따라, 서브 DAG의 <code class="docutils literal notranslate"><span class="pre">dag_id</span></code>는 이것의 부모와 점으로 된 접두어를 가져야 한다. <code class="docutils literal notranslate"><span class="pre">parent.child</span></code>처</li>
<li>인자를 서브 DAG 오퍼레이터로 전달함으로써 메인 DAG와 서브 DAG 사이의 인자를 공유한다(위의 예시처럼)</li>
<li>서브 DAG는 반드시 스케쥴이 있어야 하고 황성화되어야 한다. 만일 서브 DAG의 스케쥴이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 <code class="docutils literal notranslate"><span class="pre">&#64;once</span></code>로 설정되어 있다면, 서브 DAG는 아무것도 하지 않은 상태로 성공 상태 일 것이다</li>
<li>이 SubDagOperator를 지우면 내부 태스크 상태도 지워진다</li>
<li>이 SubDagOperator에서 성공 여부를 표시하는 것은 태스크 상태에 영향을 미치지 않는다</li>
<li>서브 DAG 안에서 태스크의 <code class="docutils literal notranslate"><span class="pre">depends_on_past=True</span></code>를 사용하는 것이 혼란스러울 수 있다면 이를 자제하라</li>
<li>서브 DAG의 실행자를 명시하는 것은 가능하다. 서브 DAG를 진행중인 상태로 실행하고 병렬 처리를 효과적으로 제한하려는 경우 SequentialExecutor를 사용하는 것이 일반적이다. LocalExecutor를 사용하면 하나의 슬롯에 여러 태스크를 실행하면서 워커에 초과할당하게 됨으로 문제가 발생할 수 있다</li>
</ul>
<p>데모 <code class="docutils literal notranslate"><span class="pre">airflow/example_dags</span></code>를 보라.</p>
<p>에어플로우 풀은 SubDagOperator에서 통용되지 않음을 유의하라. 따라서 리소스는 SubdagOperator에 의해 소비될 수 있다.</p>
</div>
<div class="section" id="slas">
<h3>SLAs<a class="headerlink" href="#slas" title="제목 주소">¶</a></h3>
<p>서비스 수준의 동의 또는 태스크나 DAG가 수행되는 시간은 태스크의 수준을 <code class="docutils literal notranslate"><span class="pre">timedelta</span></code> 정도로 설정할 수 있다. 그때까지 한 개 또는 여러 개의 인스턴스가 성공하지 못한다면, SLA가 놓친 태스크의 목록을 자세 설명하는 알림 이메일이 전송된다. 또한 이 이벤트는 데이터베이스에도 저장되고 이벤트가 분석되고 문서화되는 <code class="docutils literal notranslate"><span class="pre">Browse-&gt;SLA</span> <span class="pre">Misses</span></code> 아래의 웹 UI에서도 제공된다.</p>
<div class="section" id="email-configuration">
<h4>이메일 설정<a class="headerlink" href="#email-configuration" title="제목 주소">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">email</span></code> 섹션에 <code class="docutils literal notranslate"><span class="pre">html_content_template</span></code>이나 <code class="docutils literal notranslate"><span class="pre">subject_template</span></code>을 설정함으로써 <code class="docutils literal notranslate"><span class="pre">airflow.cfg</span></code>로 전송되는 이메일을 설정할 수 있다.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">email</span><span class="p">]</span>

<span class="n">email_backend</span> <span class="o">=</span> <span class="n">airflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">send_email_smtp</span>

<span class="n">subject_template</span> <span class="o">=</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">my_subject_template_file</span>
<span class="n">html_content_template</span> <span class="o">=</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">my_html_content_template_file</span>
</pre></div>
</div>
<p>태스크의 정보에 접근할 수 있도록  템플릿 파인 안에서 <a class="reference external" href="http://jinja.pocoo.org/docs/dev/">Jinja Templating</a>  을 사용한다.</p>
<p>예를 들어 <code class="docutils literal notranslate"><span class="pre">html_content_template</span></code> 파일은 다음과 같이 생겼다:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Try</span> <span class="p">{{</span><span class="n">try_number</span><span class="p">}}</span> <span class="n">out</span> <span class="n">of</span> <span class="p">{{</span><span class="n">max_tries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}}</span><span class="o">&lt;</span><span class="n">br</span><span class="o">&gt;</span>
<span class="ne">Exception</span><span class="p">:</span><span class="o">&lt;</span><span class="n">br</span><span class="o">&gt;</span><span class="p">{{</span><span class="n">exception_html</span><span class="p">}}</span><span class="o">&lt;</span><span class="n">br</span><span class="o">&gt;</span>
<span class="n">Log</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;{{ti.log_url}}&quot;</span><span class="o">&gt;</span><span class="n">Link</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">br</span><span class="o">&gt;</span>
<span class="n">Host</span><span class="p">:</span> <span class="p">{{</span><span class="n">ti</span><span class="o">.</span><span class="n">hostname</span><span class="p">}}</span><span class="o">&lt;</span><span class="n">br</span><span class="o">&gt;</span>
<span class="n">Log</span> <span class="n">file</span><span class="p">:</span> <span class="p">{{</span><span class="n">ti</span><span class="o">.</span><span class="n">log_filepath</span><span class="p">}}</span><span class="o">&lt;</span><span class="n">br</span><span class="o">&gt;</span>
<span class="n">Mark</span> <span class="n">success</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;{{ti.mark_success_url}}&quot;</span><span class="o">&gt;</span><span class="n">Link</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">br</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="trigger-rules">
<h3>트리거 규칙<a class="headerlink" href="#trigger-rules" title="제목 주소">¶</a></h3>
<p>일반적인 워크플로우를 통한 행동은 모든 직접 업스트림 작업이 성공했을 때 작업을 트리거하는 것이지만, 에어플로는 더 복잡한 종속성 설정을 허용한다.</p>
<p>모든 오퍼레이터는 생성된 태스크가 트리거 하는 방식을 정의하는 <code class="docutils literal notranslate"><span class="pre">trigger_rule</span></code> 인자를 가지고 있다. <code class="docutils literal notranslate"><span class="pre">trigger_rule</span></code>의 기본값은 <code class="docutils literal notranslate"><span class="pre">all_success</span></code>이고, 이것은 “모든 직접적인 업스트림 태스크가 성공했을 때 이 태스크를 트리거하는” 것으로 정의될 수 있다. 여기에 설명된 모든 다른 규칙들은 직계 부모 태스크에 기반하며 태스크가 생성되는 동안 다른 오퍼레이터로 전달될 수 있는 값이다:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">all_success</span></code>: (기본값) 모든 부모가 성공</li>
<li><code class="docutils literal notranslate"><span class="pre">all_failed</span></code>: 모든 부모가 <code class="docutils literal notranslate"><span class="pre">failed</span></code>이거나 <code class="docutils literal notranslate"><span class="pre">upstream_failed</span></code> 상태</li>
<li><code class="docutils literal notranslate"><span class="pre">all_done</span></code>: 모든 부모가 실행을 마침</li>
<li><code class="docutils literal notranslate"><span class="pre">one_failed</span></code>: 최소 하나의 부모가 실패한 순간에 바로 실행, 모든 부모가 완료될 때까지 기다리지 않음</li>
<li><code class="docutils literal notranslate"><span class="pre">one_success</span></code>: 하나의 부모가 성공한 순간에 바로 실행, 모든 부모가 완료될 때까지 기다리지 않음</li>
<li><code class="docutils literal notranslate"><span class="pre">none_failed</span></code>: 모든 부모가 실패(<code class="docutils literal notranslate"><span class="pre">failed</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">upstream_failed</span></code>)하지 않음. 예를 들어 모든 부모가 성공하거나 생략한 것</li>
<li><code class="docutils literal notranslate"><span class="pre">dummy</span></code>: 의존성은 단지 보기만 하고, 트리거 실행</li>
</ul>
<p>이러한 방법은 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정된 경우에, 이전에 스케쥴에서 성공 여부에 따라 태스크가 트리거 되도록 하는 <code class="docutils literal notranslate"><span class="pre">depends_on_past</span></code>(boolean)와 함께 사용함을 유의하라.</p>
<p>트리거 규칙과 스케쥴 레벨에서 생략된 태스크 사이의 상호작용을 잘 알아야 한다. 생략된 태스크는 트리거 규칙 <code class="docutils literal notranslate"><span class="pre">all_success</span></code>와 <code class="docutils literal notranslate"><span class="pre">all_failed</span></code>을 차례로 통과하지만 <code class="docutils literal notranslate"><span class="pre">all_done</span></code>, <code class="docutils literal notranslate"><span class="pre">one_failed</span></code>, <code class="docutils literal notranslate"><span class="pre">one_Success</span></code>, <code class="docutils literal notranslate"><span class="pre">none_failed</span></code> 그리고 <code class="docutils literal notranslate"><span class="pre">dummy</span></code>는 통과하지 않는다.</p>
<p>예를 들어, 다음의 DAG를 살펴보자:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#dags/branch_without_trigger.py</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>

<span class="kn">from</span> <span class="nn">airflow.models</span> <span class="k">import</span> <span class="n">DAG</span>
<span class="kn">from</span> <span class="nn">airflow.operators.dummy_operator</span> <span class="k">import</span> <span class="n">DummyOperator</span>
<span class="kn">from</span> <span class="nn">airflow.operators.python_operator</span> <span class="k">import</span> <span class="n">BranchPythonOperator</span>

<span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span>
    <span class="n">dag_id</span><span class="o">=</span><span class="s1">&#39;branch_without_trigger&#39;</span><span class="p">,</span>
    <span class="n">schedule_interval</span><span class="o">=</span><span class="s1">&#39;@once&#39;</span><span class="p">,</span>
    <span class="n">start_date</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2019</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">run_this_first</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;run_this_first&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>
<span class="n">branching</span> <span class="o">=</span> <span class="n">BranchPythonOperator</span><span class="p">(</span>
    <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;branching&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">,</span>
    <span class="n">python_callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="s1">&#39;branch_a&#39;</span>
<span class="p">)</span>

<span class="n">branch_a</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;branch_a&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>
<span class="n">follow_branch_a</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;follow_branch_a&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>

<span class="n">branch_false</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;branch_false&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>

<span class="n">join</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;join&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>

<span class="n">run_this_first</span> <span class="o">&gt;&gt;</span> <span class="n">branching</span>
<span class="n">branching</span> <span class="o">&gt;&gt;</span> <span class="n">branch_a</span> <span class="o">&gt;&gt;</span> <span class="n">follow_branch_a</span> <span class="o">&gt;&gt;</span> <span class="n">join</span>
<span class="n">branching</span> <span class="o">&gt;&gt;</span> <span class="n">branch_false</span> <span class="o">&gt;&gt;</span> <span class="n">join</span>
</pre></div>
</div>
<p>이러한 경우의 DAG는, <code class="docutils literal notranslate"><span class="pre">join</span></code>은 <code class="docutils literal notranslate"><span class="pre">follow_branch_a</span></code>와 <code class="docutils literal notranslate"><span class="pre">branch_false</span></code>의 다운스트림이다. <code class="docutils literal notranslate"><span class="pre">join</span></code> 태스크는 생략된 상태로 보여지는데 그 이유는 이 태스크의 <code class="docutils literal notranslate"><span class="pre">trigger_rule</span></code>이 기본적으로 <code class="docutils literal notranslate"><span class="pre">all_success</span></code>으로 설정되었고 생략된 태스크는 <code class="docutils literal notranslate"><span class="pre">all_success</span></code>를 연결하여 지나갈 것이기 때문이다.</p>
<img alt="_images/branch_without_trigger.png" src="_images/branch_without_trigger.png" />
<p><code class="docutils literal notranslate"><span class="pre">join</span></code> 태스크 안의 <code class="docutils literal notranslate"><span class="pre">trigger_rule</span></code>을 <code class="docutils literal notranslate"><span class="pre">none_failed</span></code>로 설정하면,</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#dags/branch_with_trigger.py</span>
<span class="o">...</span>
<span class="n">join</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;join&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">,</span> <span class="n">trigger_rule</span><span class="o">=</span><span class="s1">&#39;none_failed&#39;</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">join</span></code> 태스크는 <code class="docutils literal notranslate"><span class="pre">branch_false</span></code>이 생략되고(유효한 완료 상태) <code class="docutils literal notranslate"><span class="pre">follow_branch_a</span></code>가 성공한 순간에 바로 트리거 될 것이다. 그 이유는 생략된 태스크가 <code class="docutils literal notranslate"><span class="pre">none_failed</span></code>를 연결하여 통하지 <strong>않을 것이기</strong> 때문이다.</p>
<img alt="_images/branch_with_trigger.png" src="_images/branch_with_trigger.png" />
</div>
<div class="section" id="latest-run-only">
<h3>최근 실행된 태스크<a class="headerlink" href="#latest-run-only" title="제목 주소">¶</a></h3>
<p>표준 워크플로우 행동은 특정 날짜/시간 범위 동안에 일련의 태스크를 실행하는 것을 포함한다. 하지만, 일부 워크플로우는 실행 시간과는 별개로 태스크를 수행하지만 표준 크론 작업처럼 스케쥴에 따라 실행하는 태스크를 수행하기도 한다. 이러한 경우, 일시 중지 중에 누락된 백필(backfill)이나 실행 작업은 CPU 사이클을 낭비하기만 한다.</p>
<p>이러한 경우를 위해, DAG를 위한 최근 스케쥴 동안에 실행되지 않은 태스크를 생략하기 위해 <code class="docutils literal notranslate"><span class="pre">LatestOnlyOperator</span></code>를 사용할 수 있다. <code class="docutils literal notranslate"><span class="pre">LatestOnlyOperator</span></code>는 만일 지금 당장이 현재 <code class="docutils literal notranslate"><span class="pre">execution_time</span></code>과 다음 예정된 <code class="docutils literal notranslate"><span class="pre">execution_time</span></code> 사이가 아닌 경우일 때 모든 다운스트림 태스크를 생략한다.</p>
<p>예를 들어, 다음의 DAG를 살펴보자:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#dags/latest_only_with_trigger.py</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>

<span class="kn">from</span> <span class="nn">airflow.models</span> <span class="k">import</span> <span class="n">DAG</span>
<span class="kn">from</span> <span class="nn">airflow.operators.dummy_operator</span> <span class="k">import</span> <span class="n">DummyOperator</span>
<span class="kn">from</span> <span class="nn">airflow.operators.latest_only_operator</span> <span class="k">import</span> <span class="n">LatestOnlyOperator</span>
<span class="kn">from</span> <span class="nn">airflow.utils.trigger_rule</span> <span class="k">import</span> <span class="n">TriggerRule</span>


<span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span>
    <span class="n">dag_id</span><span class="o">=</span><span class="s1">&#39;latest_only_with_trigger&#39;</span><span class="p">,</span>
    <span class="n">schedule_interval</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">start_date</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2019</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">latest_only</span> <span class="o">=</span> <span class="n">LatestOnlyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;latest_only&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>

<span class="n">task1</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;task1&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>
<span class="n">task1</span><span class="o">.</span><span class="n">set_upstream</span><span class="p">(</span><span class="n">latest_only</span><span class="p">)</span>

<span class="n">task2</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;task2&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>

<span class="n">task3</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;task3&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>
<span class="n">task3</span><span class="o">.</span><span class="n">set_upstream</span><span class="p">([</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">])</span>

<span class="n">task4</span> <span class="o">=</span> <span class="n">DummyOperator</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;task4&#39;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">,</span>
                      <span class="n">trigger_rule</span><span class="o">=</span><span class="n">TriggerRule</span><span class="o">.</span><span class="n">ALL_DONE</span><span class="p">)</span>
<span class="n">task4</span><span class="o">.</span><span class="n">set_upstream</span><span class="p">([</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">])</span>
</pre></div>
</div>
<p>이 DAG의 경우, <code class="docutils literal notranslate"><span class="pre">latest_only</span></code> 태스크는 가장 최근의 실행을 제외한 모든 실행을 생략하여 보여줄 것이다. <code class="docutils literal notranslate"><span class="pre">task1</span></code>은 <code class="docutils literal notranslate"><span class="pre">latest_only</span></code>의 직접적인 다운스크림이고 최근 것을 제외한 모든 실행을 생략할 것이다. <code class="docutils literal notranslate"><span class="pre">task2</span></code>는 <code class="docutils literal notranslate"><span class="pre">latest_only</span></code>에 전적으로 독립되어 있으며 모든 예정된 기간 동안에 실행할 것이다. <code class="docutils literal notranslate"><span class="pre">task3</span></code>은 <code class="docutils literal notranslate"><span class="pre">task1</span></code>와 <code class="docutils literal notranslate"><span class="pre">tast2</span></code>의 다운스트림이며 기본 <code class="docutils literal notranslate"><span class="pre">trigger_rule</span></code>이 <code class="docutils literal notranslate"><span class="pre">all_success</span></code>이기 때문에 <code class="docutils literal notranslate"><span class="pre">task1</span></code>에서부터 일괄적으로 생략될 것이다. <code class="docutils literal notranslate"><span class="pre">task4</span></code>는 <code class="docutils literal notranslate"><span class="pre">task1</span></code>과 <code class="docutils literal notranslate"><span class="pre">task2</span></code>의 다운스트림이다. 이것은 처음에 <code class="docutils literal notranslate"><span class="pre">LatestOnlyOperator</span></code>에 의해 직접 생략될 것이며, <code class="docutils literal notranslate"><span class="pre">trigger_rule</span></code>은 <code class="docutils literal notranslate"><span class="pre">all_done</span></code>으로 설정되어 있다.</p>
<img alt="_images/latest_only_with_trigger.png" src="_images/latest_only_with_trigger.png" />
</div>
<div class="section" id="zombies-undeads">
<h3>좀비와 완전히 죽지 않은 태스크<a class="headerlink" href="#zombies-undeads" title="제목 주소">¶</a></h3>
<p>태스크 인스턴스는 항상 사라지며, 보통 일반적인 라이프 사이클의 한 부분이지만, 어떨 때는 예상하지 못한 순간에 죽기도 하다.</p>
<p>좀비 태스크는 심장박동(주기적인 실행에서 나오는)가 없으며 데이터베이스에서는 <code class="docutils literal notranslate"><span class="pre">running</span></code> 상태인 것이 특징이다. 워커 노드가 데이터베이스에 도달하지 못할 때, 에어플로우 프로세스가 외부에서 킬 되었을 때, 또는 노드가 인스턴스로 다시 부팅되었을 때 발생할 수 있다. 좀비 태스크를 제거하는 것은 스케쥴러의 프로세스에 의해 주기적으로 수행된다.</p>
<p>죽지 않은 프로세스들은 프로세스와 이에 일치하는 심장 박동이 있는 것이 특징이지만, 에어플로우는 이 태스크가 데이터베이스에서 <code class="docutils literal notranslate"><span class="pre">running</span></code> 상태인 것으로 알지 못한다. 이러한 불일치는 일반적으로 데이터베이스가 변경되는 상태에서 발생하며, 대부분의 경우 UI의 “Task Instances” 보기에서 행을 삭제하며 발생할 수 있다. 태스크는 심장 박동 루틴의 일부로 상태를 확인하고, “undead” 상태인지를 판별하는 것을 알게 되면 스스로 종료하도록 지시받는다.</p>
</div>
<div class="section" id="cluster-policy">
<h3>클러스터 정책<a class="headerlink" href="#cluster-policy" title="제목 주소">¶</a></h3>
<p>로컬 에어플로우 설정 파일은 DAG 속성 또는 다른 태스크에 따라 태스크 속성을 변형하는 기능을 가진 <code class="docutils literal notranslate"><span class="pre">policy</span></code> 함수를 정의할 수 있다. 테스크 객체를 참조하는 단일 인자를 받으면, 해당 속성을 변경될 것으로 예상한다.</p>
<p>예를 들어, 이 함수는 특정 오퍼레이터를 사용할 때 특정 대기열 속성을 적용하거나 태스크 타임아웃 정책을 적용하여 48시간 이상 동안 태스크가 실행되지 않도록 할 수 있다. 여기 <code class="docutils literal notranslate"><span class="pre">airflow_settings.py</span></code>안에 어떻게 생겼는지 보여주는 예시가 있다:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">policy</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;HivePartitionSensor&#39;</span><span class="p">:</span>
        <span class="n">task</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="s2">&quot;sensor_queue&quot;</span>
    <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">48</span><span class="p">):</span>
        <span class="n">task</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">48</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="documentation-notes">
<h3>문서와 노트<a class="headerlink" href="#documentation-notes" title="제목 주소">¶</a></h3>
<p>웹 인터페이스(DAG를 위한 “Graph View”, 태스크를 위한 “Task Details”)에서 보이는 DAG와 태스크 객체에 문서나 노트를 추가하는 것이 가능하다. 정의 되었을 때 리치 콘텐츠로 렌더링되는 특별한 태스크 속성이 있다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">속성</th>
<th class="head">렌더링 되는 것</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>doc</td>
<td>monospace</td>
</tr>
<tr class="row-odd"><td>doc_json</td>
<td>json</td>
</tr>
<tr class="row-even"><td>doc_yaml</td>
<td>yaml</td>
</tr>
<tr class="row-odd"><td>doc_md</td>
<td>markdown</td>
</tr>
<tr class="row-even"><td>doc_rst</td>
<td>reStructuredText</td>
</tr>
</tbody>
</table>
<p>DAG의 경우 doc_md만이 속성만이 해석된다는 것을 유의하라.</p>
<p>이는 특히 태스크가 설정 파일로부터 동적으로 빌드됐을 경우에 유용하고, 에어플로우 안에서 관련된 태스크로 이어지는 구성을 노출시킬 수 있도록 허용한다.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">### My great DAG</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="s1">&#39;my_dag&#39;</span><span class="p">,</span> <span class="n">default_args</span><span class="o">=</span><span class="n">default_args</span><span class="p">)</span>
<span class="n">dag</span><span class="o">.</span><span class="n">doc_md</span> <span class="o">=</span> <span class="vm">__doc__</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">BashOperator</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">doc_md</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#Title&quot;</span>
<span class="s2">Here&#39;s a [url](www.airbnb.com)</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>이 내용은 “Graph View”와 “Task Details” 페이지에서 각각 마크다운 형태로 렌더링 된다.</p>
</div>
<div class="section" id="id1">
<span id="id2"></span><h3>Jinja 템플릿<a class="headerlink" href="#id1" title="제목 주소">¶</a></h3>
<p>에어플로우는 <a class="reference external" href="http://jinja.pocoo.org/docs/dev/">Jinja Templating</a> 의 힘을 활용하는데, 이는 매크로와 결합하여 사용하는데 강력한 도구가 될 수 있다(<a class="reference internal" href="macros.html"><span class="doc">Macros reference</span></a> 부분을 보라).</p>
<p>예를 들어, <cite>BashOperator`</cite>를 사용하여 bash 스크립트에 실행 날짜를 환경 변수로써 넘기고 싶다고 하자.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># The execution date as YYYY-MM-DD</span>
<span class="n">date</span> <span class="o">=</span> <span class="s2">&quot;{{ ds }}&quot;</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">BashOperator</span><span class="p">(</span>
    <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;test_env&#39;</span><span class="p">,</span>
    <span class="n">bash_command</span><span class="o">=</span><span class="s1">&#39;/tmp/test.sh &#39;</span><span class="p">,</span>
    <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">,</span>
    <span class="n">env</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;EXECUTION_DATE&#39;</span><span class="p">:</span> <span class="n">date</span><span class="p">})</span>
</pre></div>
</div>
<p>여기, <code class="docutils literal notranslate"><span class="pre">{{</span> <span class="pre">ds</span> <span class="pre">}}</span></code>는 매크로이고, <code class="docutils literal notranslate"><span class="pre">BashOperator</span></code>의 <code class="docutils literal notranslate"><span class="pre">env</span></code> 파라미터가 Jinja 템플릿으로 되어 있기 때문에, 실행 날짜는 bash 스크립트에서 <code class="docutils literal notranslate"><span class="pre">EXECUTION_DATE</span></code>라는 이름의 환경 변수로 사용이 가능할 것이다.</p>
<p>문서에서 “templated”로 표시된 모든 파라미터는 Jinja 템플릿화 해서 사용할 수 있다. 템플릿의 대입은 오퍼레이터의 pre_execute 함수가 호출되기 바로 직전에 발생한다.</p>
</div>
</div>
<div class="section" id="packaged-dags">
<h2>패키지 된 DAG<a class="headerlink" href="#packaged-dags" title="제목 주소">¶</a></h2>
<p>단일 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 파일에서 DAG를 명시하는 경우가 많지만 때로는 DAG와 그 종속성을 결합하는 것이 요구될 때가 있다. 예를 들어, 여러 개의 한 번에 DAG를 결합하여 함께 버전을 만들거나 함께 관리하거나 에어플로우를 실행하는 시스템에서 기본값으로 사용할 수 없는 추가적인 모듈이 필요할 수 있다. 이러한 것들을 허용하기 위해 파일 루트에 DAG가 들어있는 zip 파일을 생성하고 디렉토리 내에 추가 모듈을 언팩할 수 있다.</p>
<p>예를 들어 다음과 같이 zip 파일을 생성할 수 있다:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>my_dag1.py
my_dag2.py
package1/__init__.py
package1/functions.py
</pre></div>
</div>
<p>에어플로우는 zip 파일을 살펴보고 <code class="docutils literal notranslate"><span class="pre">my_dag1.py</span></code>와 <code class="docutils literal notranslate"><span class="pre">my_dag2.py</span></code>를 로드하려 시도할 것이다. 이는 잠재적인 패키지가 될 수 있는 것으로 보기 때문에 있는 하위 디렉토리 내에 들어가지 않을 것이다.</p>
<p>DAG에 모듈 의존성을 추가하고 싶을 경우 기본적으로 동일하게 하면 되지만 virtualenv와 pip을 더 사용하게 된다.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>virtualenv zip_dag
<span class="nb">source</span> zip_dag/bin/activate

mkdir zip_dag_contents
<span class="nb">cd</span> zip_dag_contents

pip install --install-option<span class="o">=</span><span class="s2">&quot;--install-lib=</span><span class="nv">$PWD</span><span class="s2">&quot;</span> my_useful_package
cp ~/my_dag.py .

zip -r zip_dag.zip *
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 zip 파일은 모듈 검색 목록의 시작 부분에 삽입되며 동일한 인터프리터 내의 다른 코드에서 사용이 가능할 것이다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">패키지 된 dag들은 피클링되어 사용할 수 없다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">패키지 된 dag는 모듈에서 시스템에서 사용할 수 있는 동적 라이브러리(예를 들어 libz.so)를 필요로 할 경우라도 이러한 동적 라이브러리를 포함할 수 없다.</p>
</div>
</div>
<div class="section" id="airflowignore">
<h2>.airflowignore<a class="headerlink" href="#airflowignore" title="제목 주소">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">.airflowignore</span></code> 파일은 <code class="docutils literal notranslate"><span class="pre">DAG_FOLDER</span></code> 안의 디렉토리나 파일을 명시하는데 에어플로우는 의도적으로 이것을 무시해야 한다. <code class="docutils literal notranslate"><span class="pre">.airflowignore</span></code>의 각 행은 정규 표현식 패턴으로 작성되는데, 이 패턴과 매치되는 이름의 모든 디렉토리 또는 파일(DAG id는 아님)은 무시될 것이다(hood 아래에서는 패턴과 일치하는 <code class="docutils literal notranslate"><span class="pre">re.findall()</span></code>을 사용한다). 대체로 <code class="docutils literal notranslate"><span class="pre">.gitignore</span></code> 파일처럼 작동한다.</p>
<p><code class="docutils literal notranslate"><span class="pre">.airflowignore</span></code> 파일은 <code class="docutils literal notranslate"><span class="pre">DAG_FOLDER</span></code> 내부에 있어야 한다. 예를 들어, 아래의 내용을 담고 있는 <code class="docutils literal notranslate"><span class="pre">.airflowignore</span></code> 파일을 준비했다고 하자</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">project_a</span>
<span class="n">tenant_</span><span class="p">[</span>\<span class="n">d</span><span class="p">]</span>
</pre></div>
</div>
<p>“DAG_FOLDER” 내의 “project_a_dag_1.py”, “TESTING_project_a.py”, “tenant_1.py”, “project_a/dag_1.py”, 그리고 “tenant_1/dag_1.py”와 같은 파일들은 무시될 것이다(만약 디렉토리 이름이 이런 패턴과 매치될 경우, 이 디렉토리와 내부의 하위 폴더들은 Airflow에 의해 스캔되지 않을 것이다. 이는 DAG 파인딩의 효율성을 높인다).</p>
<p><code class="docutils literal notranslate"><span class="pre">.airflowignore</span></code> 파일의 범위는 디렉토리와 그 하위의 모든 폴더이다. 또한 <code class="docutils literal notranslate"><span class="pre">.airflowignore</span></code> 파일을 <code class="docutils literal notranslate"><span class="pre">DAG_FOLDER</span></code>의 하위 폴더 안에 놓을 수 있으며 그 하위 서브폴더 내에서만 적용될 것이다.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cli.html" class="btn btn-neutral float-right" title="Command Line Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ui.html" class="btn btn-neutral" title="UI / 스크린샷(Screenshots)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.10.1',
            LANGUAGE:'ko',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>